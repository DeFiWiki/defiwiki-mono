{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/not-sync/git2/defiwiki-mono/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"C:/not-sync/git2/defiwiki-mono/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/not-sync/git2/defiwiki-mono/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DID = void 0;\n\nvar did_resolver_1 = require(\"did-resolver\");\n\nvar did_jwt_1 = require(\"did-jwt\");\n\nvar dag_jose_utils_1 = require(\"dag-jose-utils\");\n\nvar rpc_utils_1 = require(\"rpc-utils\");\n\nvar utils_1 = require(\"./utils\");\n\nfunction isResolver(resolver) {\n  return 'registry' in resolver && 'cache' in resolver;\n}\n\nvar DID = /*#__PURE__*/function () {\n  function DID() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        provider = _ref.provider,\n        _ref$resolver = _ref.resolver,\n        resolver = _ref$resolver === void 0 ? {} : _ref$resolver,\n        resolverOptions = _ref.resolverOptions;\n\n    _classCallCheck(this, DID);\n\n    if (provider != null) {\n      this._client = new rpc_utils_1.RPCClient(provider);\n    }\n\n    this.setResolver(resolver, resolverOptions);\n  }\n\n  _createClass(DID, [{\n    key: \"authenticated\",\n    get: function get() {\n      return this._id != null;\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      if (this._id == null) {\n        throw new Error('DID is not authenticated');\n      }\n\n      return this._id;\n    }\n  }, {\n    key: \"setProvider\",\n    value: function setProvider(provider) {\n      if (this._client == null) {\n        this._client = new rpc_utils_1.RPCClient(provider);\n      } else if (this._client.connection !== provider) {\n        throw new Error('A different provider is already set, create a new DID instance to use another provider');\n      }\n    }\n  }, {\n    key: \"setResolver\",\n    value: function setResolver(resolver, resolverOptions) {\n      this._resolver = isResolver(resolver) ? resolver : new did_resolver_1.Resolver(resolver, resolverOptions);\n    }\n  }, {\n    key: \"authenticate\",\n    value: function authenticate() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          provider = _ref2.provider,\n          _ref2$paths = _ref2.paths,\n          paths = _ref2$paths === void 0 ? [] : _ref2$paths,\n          aud = _ref2.aud;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var nonce, jws, _yield$this$verifyJWS, kid, payload;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (provider != null) {\n                  this.setProvider(provider);\n                }\n\n                if (!(this._client == null)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new Error('No provider available');\n\n              case 3:\n                nonce = utils_1.randomString();\n                _context.next = 6;\n                return this._client.request('did_authenticate', {\n                  nonce: nonce,\n                  aud: aud,\n                  paths: paths\n                });\n\n              case 6:\n                jws = _context.sent;\n                _context.next = 9;\n                return this.verifyJWS(jws);\n\n              case 9:\n                _yield$this$verifyJWS = _context.sent;\n                kid = _yield$this$verifyJWS.kid;\n                payload = utils_1.base64urlToJSON(jws.payload);\n\n                if (kid.includes(payload.did)) {\n                  _context.next = 14;\n                  break;\n                }\n\n                throw new Error('Invalid authencation response, kid mismatch');\n\n              case 14:\n                if (!(payload.nonce !== nonce)) {\n                  _context.next = 16;\n                  break;\n                }\n\n                throw new Error('Invalid authencation response, wrong nonce');\n\n              case 16:\n                if (!(payload.aud !== aud)) {\n                  _context.next = 18;\n                  break;\n                }\n\n                throw new Error('Invalid authencation response, wrong aud');\n\n              case 18:\n                if (!(payload.exp < Date.now() / 1000)) {\n                  _context.next = 20;\n                  break;\n                }\n\n                throw new Error('Invalid authencation response, expired');\n\n              case 20:\n                this._id = payload.did;\n                return _context.abrupt(\"return\", this._id);\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"createJWS\",\n    value: function createJWS(payload) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _yield$this$_client$r, jws;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this._client == null)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error('No provider available');\n\n              case 2:\n                if (!(this._id == null)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                throw new Error('DID is not authenticated');\n\n              case 4:\n                _context2.next = 6;\n                return this._client.request('did_createJWS', Object.assign(Object.assign({\n                  did: this._id\n                }, options), {\n                  payload: payload\n                }));\n\n              case 6:\n                _yield$this$_client$r = _context2.sent;\n                jws = _yield$this$_client$r.jws;\n                return _context2.abrupt(\"return\", jws);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"createDagJWS\",\n    value: function createDagJWS(payload) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _yield$dag_jose_utils, cid, linkedBlock, payloadCid, jws;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return dag_jose_utils_1.encodePayload(payload);\n\n              case 2:\n                _yield$dag_jose_utils = _context3.sent;\n                cid = _yield$dag_jose_utils.cid;\n                linkedBlock = _yield$dag_jose_utils.linkedBlock;\n                payloadCid = utils_1.encodeBase64Url(cid.bytes);\n                Object.assign(options, {\n                  linkedBlock: utils_1.encodeBase64(linkedBlock)\n                });\n                _context3.next = 9;\n                return this.createJWS(payloadCid, options);\n\n              case 9:\n                jws = _context3.sent;\n                jws.link = cid;\n                return _context3.abrupt(\"return\", {\n                  jws: jws,\n                  linkedBlock: linkedBlock\n                });\n\n              case 12:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"verifyJWS\",\n    value: function verifyJWS(jws) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _a, _b, _c, _d, _e;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var kid, didResolutionResult, timecheckEnabled, nextUpdate, isEarlier, isLater, updated, signerDid, issuerUrl, issuerResolution, controllerProperty, controllers, signerIsController, publicKeys, payload;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (typeof jws !== 'string') jws = utils_1.fromDagJWS(jws);\n                kid = utils_1.base64urlToJSON(jws.split('.')[0]).kid;\n\n                if (kid) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                throw new Error('No \"kid\" found in jws');\n\n              case 4:\n                _context4.next = 6;\n                return this.resolve(kid);\n\n              case 6:\n                didResolutionResult = _context4.sent;\n                timecheckEnabled = !options.disableTimecheck;\n\n                if (!timecheckEnabled) {\n                  _context4.next = 18;\n                  break;\n                }\n\n                nextUpdate = (_a = didResolutionResult.didDocumentMetadata) === null || _a === void 0 ? void 0 : _a.nextUpdate;\n\n                if (!nextUpdate) {\n                  _context4.next = 15;\n                  break;\n                }\n\n                isEarlier = options.atTime && options.atTime < new Date(nextUpdate).valueOf();\n                isLater = !isEarlier;\n\n                if (!isLater) {\n                  _context4.next = 15;\n                  break;\n                }\n\n                throw new Error(\"invalid_jws: signature authored with a revoked DID version: \".concat(kid));\n\n              case 15:\n                updated = (_b = didResolutionResult.didDocumentMetadata) === null || _b === void 0 ? void 0 : _b.updated;\n\n                if (!(updated && options.atTime && options.atTime < new Date(updated).valueOf())) {\n                  _context4.next = 18;\n                  break;\n                }\n\n                throw new Error(\"invalid_jws: signature authored before creation of DID version: \".concat(kid));\n\n              case 18:\n                signerDid = (_c = didResolutionResult.didDocument) === null || _c === void 0 ? void 0 : _c.id;\n\n                if (!(options.issuer && options.issuer !== signerDid)) {\n                  _context4.next = 29;\n                  break;\n                }\n\n                issuerUrl = utils_1.didWithTime(options.issuer, options.atTime);\n                _context4.next = 23;\n                return this.resolve(issuerUrl);\n\n              case 23:\n                issuerResolution = _context4.sent;\n                controllerProperty = (_d = issuerResolution.didDocument) === null || _d === void 0 ? void 0 : _d.controller;\n                controllers = utils_1.extractControllers(controllerProperty);\n                signerIsController = signerDid ? controllers.includes(signerDid) : false;\n\n                if (signerIsController) {\n                  _context4.next = 29;\n                  break;\n                }\n\n                throw new Error(\"invalid_jws: not a valid verificationMethod for issuer: \".concat(kid));\n\n              case 29:\n                publicKeys = ((_e = didResolutionResult.didDocument) === null || _e === void 0 ? void 0 : _e.verificationMethod) || [];\n                did_jwt_1.verifyJWS(jws, publicKeys);\n\n                try {\n                  payload = utils_1.base64urlToJSON(jws.split('.')[1]);\n                } catch (e) {}\n\n                return _context4.abrupt(\"return\", {\n                  kid: kid,\n                  payload: payload,\n                  didResolutionResult: didResolutionResult\n                });\n\n              case 33:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"createJWE\",\n    value: function createJWE(cleartext, recipients) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var encrypters;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return did_jwt_1.resolveX25519Encrypters(recipients, this._resolver);\n\n              case 2:\n                encrypters = _context5.sent;\n                return _context5.abrupt(\"return\", did_jwt_1.createJWE(cleartext, encrypters, options.protectedHeader, options.aad));\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n  }, {\n    key: \"createDagJWE\",\n    value: function createDagJWE(cleartext, recipients) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", this.createJWE(dag_jose_utils_1.prepareCleartext(cleartext), recipients, options));\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"decryptJWE\",\n    value: function decryptJWE(jwe) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var _yield$this$_client$r2, cleartext;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(this._client == null)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw new Error('No provider available');\n\n              case 2:\n                if (!(this._id == null)) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                throw new Error('DID is not authenticated');\n\n              case 4:\n                _context7.next = 6;\n                return this._client.request('did_decryptJWE', Object.assign(Object.assign({\n                  did: this._id\n                }, options), {\n                  jwe: jwe\n                }));\n\n              case 6:\n                _yield$this$_client$r2 = _context7.sent;\n                cleartext = _yield$this$_client$r2.cleartext;\n                return _context7.abrupt(\"return\", utils_1.decodeBase64(cleartext));\n\n              case 9:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n  }, {\n    key: \"decryptDagJWE\",\n    value: function decryptDagJWE(jwe) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var bytes;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.decryptJWE(jwe);\n\n              case 2:\n                bytes = _context8.sent;\n                return _context8.abrupt(\"return\", dag_jose_utils_1.decodeCleartext(bytes));\n\n              case 4:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(didUrl) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var result, _result$didResolution, error, message, maybeMessage;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this._resolver.resolve(didUrl);\n\n              case 2:\n                result = _context9.sent;\n\n                if (!result.didResolutionMetadata.error) {\n                  _context9.next = 7;\n                  break;\n                }\n\n                _result$didResolution = result.didResolutionMetadata, error = _result$didResolution.error, message = _result$didResolution.message;\n                maybeMessage = message ? \", \".concat(message) : '';\n                throw new Error(\"Failed to resolve \".concat(didUrl, \": \").concat(error).concat(maybeMessage));\n\n              case 7:\n                return _context9.abrupt(\"return\", result);\n\n              case 8:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n    }\n  }]);\n\n  return DID;\n}();\n\nexports.DID = DID;","map":{"version":3,"sources":["../src/did.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DID = void 0;\nconst did_resolver_1 = require(\"did-resolver\");\nconst did_jwt_1 = require(\"did-jwt\");\nconst dag_jose_utils_1 = require(\"dag-jose-utils\");\nconst rpc_utils_1 = require(\"rpc-utils\");\nconst utils_1 = require(\"./utils\");\nfunction isResolver(resolver) {\n    return 'registry' in resolver && 'cache' in resolver;\n}\nclass DID {\n    constructor({ provider, resolver = {}, resolverOptions } = {}) {\n        if (provider != null) {\n            this._client = new rpc_utils_1.RPCClient(provider);\n        }\n        this.setResolver(resolver, resolverOptions);\n    }\n    get authenticated() {\n        return this._id != null;\n    }\n    get id() {\n        if (this._id == null) {\n            throw new Error('DID is not authenticated');\n        }\n        return this._id;\n    }\n    setProvider(provider) {\n        if (this._client == null) {\n            this._client = new rpc_utils_1.RPCClient(provider);\n        }\n        else if (this._client.connection !== provider) {\n            throw new Error('A different provider is already set, create a new DID instance to use another provider');\n        }\n    }\n    setResolver(resolver, resolverOptions) {\n        this._resolver = isResolver(resolver) ? resolver : new did_resolver_1.Resolver(resolver, resolverOptions);\n    }\n    authenticate({ provider, paths = [], aud } = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (provider != null) {\n                this.setProvider(provider);\n            }\n            if (this._client == null) {\n                throw new Error('No provider available');\n            }\n            const nonce = utils_1.randomString();\n            const jws = yield this._client.request('did_authenticate', {\n                nonce,\n                aud,\n                paths,\n            });\n            const { kid } = yield this.verifyJWS(jws);\n            const payload = utils_1.base64urlToJSON(jws.payload);\n            if (!kid.includes(payload.did))\n                throw new Error('Invalid authencation response, kid mismatch');\n            if (payload.nonce !== nonce)\n                throw new Error('Invalid authencation response, wrong nonce');\n            if (payload.aud !== aud)\n                throw new Error('Invalid authencation response, wrong aud');\n            if (payload.exp < Date.now() / 1000)\n                throw new Error('Invalid authencation response, expired');\n            this._id = payload.did;\n            return this._id;\n        });\n    }\n    createJWS(payload, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._client == null)\n                throw new Error('No provider available');\n            if (this._id == null)\n                throw new Error('DID is not authenticated');\n            const { jws } = yield this._client.request('did_createJWS', Object.assign(Object.assign({ did: this._id }, options), { payload }));\n            return jws;\n        });\n    }\n    createDagJWS(payload, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { cid, linkedBlock } = yield dag_jose_utils_1.encodePayload(payload);\n            const payloadCid = utils_1.encodeBase64Url(cid.bytes);\n            Object.assign(options, { linkedBlock: utils_1.encodeBase64(linkedBlock) });\n            const jws = yield this.createJWS(payloadCid, options);\n            jws.link = cid;\n            return { jws, linkedBlock };\n        });\n    }\n    verifyJWS(jws, options = {}) {\n        var _a, _b, _c, _d, _e;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof jws !== 'string')\n                jws = utils_1.fromDagJWS(jws);\n            const kid = utils_1.base64urlToJSON(jws.split('.')[0]).kid;\n            if (!kid)\n                throw new Error('No \"kid\" found in jws');\n            const didResolutionResult = yield this.resolve(kid);\n            const timecheckEnabled = !options.disableTimecheck;\n            if (timecheckEnabled) {\n                const nextUpdate = (_a = didResolutionResult.didDocumentMetadata) === null || _a === void 0 ? void 0 : _a.nextUpdate;\n                if (nextUpdate) {\n                    const isEarlier = options.atTime && options.atTime < new Date(nextUpdate).valueOf();\n                    const isLater = !isEarlier;\n                    if (isLater) {\n                        throw new Error(`invalid_jws: signature authored with a revoked DID version: ${kid}`);\n                    }\n                }\n                const updated = (_b = didResolutionResult.didDocumentMetadata) === null || _b === void 0 ? void 0 : _b.updated;\n                if (updated && options.atTime && options.atTime < new Date(updated).valueOf()) {\n                    throw new Error(`invalid_jws: signature authored before creation of DID version: ${kid}`);\n                }\n            }\n            const signerDid = (_c = didResolutionResult.didDocument) === null || _c === void 0 ? void 0 : _c.id;\n            if (options.issuer && options.issuer !== signerDid) {\n                const issuerUrl = utils_1.didWithTime(options.issuer, options.atTime);\n                const issuerResolution = yield this.resolve(issuerUrl);\n                const controllerProperty = (_d = issuerResolution.didDocument) === null || _d === void 0 ? void 0 : _d.controller;\n                const controllers = utils_1.extractControllers(controllerProperty);\n                const signerIsController = signerDid ? controllers.includes(signerDid) : false;\n                if (!signerIsController) {\n                    throw new Error(`invalid_jws: not a valid verificationMethod for issuer: ${kid}`);\n                }\n            }\n            const publicKeys = ((_e = didResolutionResult.didDocument) === null || _e === void 0 ? void 0 : _e.verificationMethod) || [];\n            did_jwt_1.verifyJWS(jws, publicKeys);\n            let payload;\n            try {\n                payload = utils_1.base64urlToJSON(jws.split('.')[1]);\n            }\n            catch (e) {\n            }\n            return { kid, payload, didResolutionResult };\n        });\n    }\n    createJWE(cleartext, recipients, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const encrypters = yield did_jwt_1.resolveX25519Encrypters(recipients, this._resolver);\n            return did_jwt_1.createJWE(cleartext, encrypters, options.protectedHeader, options.aad);\n        });\n    }\n    createDagJWE(cleartext, recipients, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.createJWE(dag_jose_utils_1.prepareCleartext(cleartext), recipients, options);\n        });\n    }\n    decryptJWE(jwe, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._client == null)\n                throw new Error('No provider available');\n            if (this._id == null)\n                throw new Error('DID is not authenticated');\n            const { cleartext } = yield this._client.request('did_decryptJWE', Object.assign(Object.assign({ did: this._id }, options), { jwe }));\n            return utils_1.decodeBase64(cleartext);\n        });\n    }\n    decryptDagJWE(jwe) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const bytes = yield this.decryptJWE(jwe);\n            return dag_jose_utils_1.decodeCleartext(bytes);\n        });\n    }\n    resolve(didUrl) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this._resolver.resolve(didUrl);\n            if (result.didResolutionMetadata.error) {\n                const { error, message } = result.didResolutionMetadata;\n                const maybeMessage = message ? `, ${message}` : '';\n                throw new Error(`Failed to resolve ${didUrl}: ${error}${maybeMessage}`);\n            }\n            return result;\n        });\n    }\n}\nexports.DID = DID;\n//# sourceMappingURL=did.js.map"]},"metadata":{},"sourceType":"script"}