{"ast":null,"code":"import _classCallCheck from \"C:/not-sync/git2/defiwiki-mono/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/not-sync/git2/defiwiki-mono/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _createForOfIteratorHelper from \"C:/not-sync/git2/defiwiki-mono/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"C:/not-sync/git2/defiwiki-mono/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/not-sync/git2/defiwiki-mono/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction t() {\n  return (t = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var r = arguments[e];\n\n      for (var n in r) {\n        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n      }\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nfunction e() {\n  var t = new Map();\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(e, r) {\n      var n, a, i;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(e.params && \"true\" === e.params[\"no-cache\"])) {\n                _context.next = 4;\n                break;\n              }\n\n              _context.next = 3;\n              return r();\n\n            case 3:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 4:\n              a = t.get(e.didUrl);\n\n              if (!(void 0 !== a)) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt(\"return\", a);\n\n            case 7:\n              _context.next = 9;\n              return r();\n\n            case 9:\n              i = _context.sent;\n              return _context.abrupt(\"return\", (\"notFound\" !== (null == (n = i.didResolutionMetadata) ? void 0 : n.error) && t.set(e.didUrl, i), i));\n\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nfunction r(t, e) {\n  return e();\n}\n\nvar n = new RegExp(\"^did:([a-zA-Z0-9_]+):([a-zA-Z0-9_.%-]+(:[a-zA-Z0-9_.%-]+)*)((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$\");\n\nfunction a(t) {\n  if (\"\" === t || !t) return null;\n  var e = t.match(n);\n\n  if (e) {\n    var _r = {\n      did: \"did:\".concat(e[1], \":\").concat(e[2]),\n      method: e[1],\n      id: e[2],\n      didUrl: t\n    };\n\n    if (e[4]) {\n      var _t = e[4].slice(1).split(\";\");\n\n      _r.params = {};\n\n      var _iterator = _createForOfIteratorHelper(_t),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _e = _step.value;\n\n          var _t2 = _e.split(\"=\");\n\n          _r.params[_t2[0]] = _t2[1];\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    return e[6] && (_r.path = e[6]), e[7] && (_r.query = e[7].slice(1)), e[8] && (_r.fragment = e[8].slice(1)), _r;\n  }\n\n  return null;\n}\n\nvar i = {\n  didResolutionMetadata: {},\n  didDocument: null,\n  didDocumentMetadata: {}\n};\n\nfunction o(e) {\n  return /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(r, n, a) {\n      var _o;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return e(r, n, a);\n\n            case 3:\n              _o = _context2.sent;\n              return _context2.abrupt(\"return\", t({}, i, {\n                didResolutionMetadata: {\n                  contentType: \"application/did+ld+json\"\n                },\n                didDocument: _o\n              }));\n\n            case 7:\n              _context2.prev = 7;\n              _context2.t0 = _context2[\"catch\"](0);\n              return _context2.abrupt(\"return\", t({}, i, {\n                didResolutionMetadata: {\n                  error: \"notFound\",\n                  message: _context2.t0.toString()\n                }\n              }));\n\n            case 10:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[0, 7]]);\n    }));\n\n    return function (_x3, _x4, _x5) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}\n\nvar s = /*#__PURE__*/function () {\n  function s() {\n    var _this = this;\n\n    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, s);\n\n    this.registry = t, this.cache = !0 === n.cache ? e() : n.cache || r, n.legacyResolvers && Object.keys(n.legacyResolvers).map(function (t) {\n      _this.registry[t] || (_this.registry[t] = o(n.legacyResolvers[t]));\n    });\n  }\n\n  _createClass(s, [{\n    key: \"resolve\",\n    value: function () {\n      var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(e) {\n        var _this2 = this;\n\n        var r,\n            n,\n            o,\n            _args3 = arguments;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                r = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n                n = a(e);\n\n                if (!(null === n)) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", t({}, i, {\n                  didResolutionMetadata: {\n                    error: \"invalidDid\"\n                  }\n                }));\n\n              case 4:\n                o = this.registry[n.method];\n                return _context3.abrupt(\"return\", o ? this.cache(n, function () {\n                  return o(n.did, n, _this2, r);\n                }) : t({}, i, {\n                  didResolutionMetadata: {\n                    error: \"unsupportedDidMethod\"\n                  }\n                }));\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function resolve(_x6) {\n        return _resolve.apply(this, arguments);\n      }\n\n      return resolve;\n    }()\n  }]);\n\n  return s;\n}();\n\nexport { s as Resolver, e as inMemoryCache, r as noCache, a as parse, o as wrapLegacyResolver };","map":{"version":3,"sources":["../src/resolver.ts"],"names":["inMemoryCache","cache","Map","parsed","resolve","params","cached","get","didUrl","undefined","result","didResolutionMetadata","error","set","noCache","DID_MATCHER","RegExp","parse","sections","match","parts","did","method","id","slice","split","p","kv","path","query","fragment","EMPTY_RESULT","didDocument","didDocumentMetadata","wrapLegacyResolver","resolver","doc","contentType","message","e","toString","Resolver","constructor","registry","options","this","legacyResolvers","Object","keys","map","methodName","[object Object]"],"mappings":"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","sourcesContent":["// Copyright 2018 Consensys AG\n\n// Licensed under the Apache License, Version 2.0(the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n\n// http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Extensible = Record<string, any>\n\nexport interface DIDResolutionResult {\n  didResolutionMetadata: DIDResolutionMetadata\n  didDocument: DIDDocument | null\n  didDocumentMetadata: DIDDocumentMetadata\n}\n\nexport interface DIDResolutionOptions extends Extensible {\n  accept?: string\n}\n\nexport interface DIDResolutionMetadata extends Extensible {\n  contentType?: string\n  error?:\n    | 'invalidDid'\n    | 'notFound'\n    | 'representationNotSupported'\n    | 'unsupportedDidMethod'\n    | string\n}\n\nexport interface DIDDocumentMetadata extends Extensible {\n  created?: string\n  updated?: string\n  deactivated?: boolean\n  versionId?: string\n  nextUpdate?: string\n  nextVersionId?: string\n  equivalentId?: string\n  canonicalId?: string\n}\n\nexport interface DIDDocument {\n  '@context'?: 'https://www.w3.org/ns/did/v1' | string | string[]\n  id: string\n  alsoKnownAs?: string[]\n  controller?: string | string[]\n  verificationMethod?: VerificationMethod[]\n  authentication?: (string | VerificationMethod)[]\n  assertionMethod?: (string | VerificationMethod)[]\n  keyAgreement?: (string | VerificationMethod)[]\n  capabilityInvocation?: (string | VerificationMethod)[]\n  capabilityDelegation?: (string | VerificationMethod)[]\n  service?: ServiceEndpoint[]\n  /**\n   * @deprecated\n   */\n  publicKey?: VerificationMethod[]\n}\n\nexport interface ServiceEndpoint {\n  id: string\n  type: string\n  serviceEndpoint: string\n  description?: string\n}\n\ninterface JsonWebKey extends Extensible {\n  alg?: string\n  crv?: string\n  e?: string\n  ext?: boolean\n  key_ops?: string[]\n  kid?: string\n  kty: string\n  n?: string\n  use?: string\n  x?: string\n  y?: string\n}\n\nexport interface VerificationMethod {\n  id: string\n  type: string\n  controller: string\n  publicKeyBase58?: string\n  publicKeyJwk?: JsonWebKey\n  publicKeyHex?: string\n  blockchainAccountId?: string\n  ethereumAddress?: string\n}\n\nexport interface Params {\n  [index: string]: string\n}\n\nexport interface ParsedDID {\n  did: string\n  didUrl: string\n  method: string\n  id: string\n  path?: string\n  fragment?: string\n  query?: string\n  params?: Params\n}\n\nexport type DIDResolver = (\n  did: string,\n  parsed: ParsedDID,\n  resolver: Resolver,\n  options: DIDResolutionOptions\n) => Promise<DIDResolutionResult>\nexport type WrappedResolver = () => Promise<DIDResolutionResult>\nexport type DIDCache = (\n  parsed: ParsedDID,\n  resolve: WrappedResolver\n) => Promise<DIDResolutionResult>\nexport type LegacyDIDResolver = (\n  did: string,\n  parsed: ParsedDID,\n  resolver: Resolver\n) => Promise<DIDDocument>\n\nexport interface ResolverRegistry {\n  [index: string]: DIDResolver\n}\n\nexport interface LegacyResolverRegistry {\n  [index: string]: LegacyDIDResolver\n}\n\nexport interface ResolverOptions {\n  cache?: DIDCache | boolean | undefined\n  legacyResolvers?: LegacyResolverRegistry\n}\n\nexport function inMemoryCache(): DIDCache {\n  const cache: Map<string, DIDResolutionResult> = new Map()\n  return async (parsed: ParsedDID, resolve) => {\n    if (parsed.params && parsed.params['no-cache'] === 'true')\n      return await resolve()\n\n    const cached = cache.get(parsed.didUrl)\n    if (cached !== undefined) return cached\n    const result = await resolve()\n    if (result.didResolutionMetadata?.error !== 'notFound') {\n      cache.set(parsed.didUrl, result)\n    }\n    return result\n  }\n}\n\nexport function noCache(\n  parsed: ParsedDID,\n  resolve: WrappedResolver\n): Promise<DIDResolutionResult> {\n  return resolve()\n}\n\nconst ID_CHAR = '[a-zA-Z0-9_.%-]'\nconst METHOD = '([a-zA-Z0-9_]+)'\nconst METHOD_ID = `(${ID_CHAR}+(:${ID_CHAR}+)*)`\nconst PARAM_CHAR = '[a-zA-Z0-9_.:%-]'\nconst PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`\nconst PARAMS = `((${PARAM})*)`\nconst PATH = `(\\/[^#?]*)?`\nconst QUERY = `([?][^#]*)?`\nconst FRAGMENT = `(\\#.*)?`\nconst DID_MATCHER = new RegExp(\n  `^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`\n)\nexport function parse(didUrl: string): ParsedDID | null {\n  if (didUrl === '' || !didUrl) return null\n  const sections = didUrl.match(DID_MATCHER)\n  if (sections) {\n    const parts: ParsedDID = {\n      did: `did:${sections[1]}:${sections[2]}`,\n      method: sections[1],\n      id: sections[2],\n      didUrl\n    }\n    if (sections[4]) {\n      const params = sections[4].slice(1).split(';')\n      parts.params = {}\n      for (const p of params) {\n        const kv = p.split('=')\n        parts.params[kv[0]] = kv[1]\n      }\n    }\n    if (sections[6]) parts.path = sections[6]\n    if (sections[7]) parts.query = sections[7].slice(1)\n    if (sections[8]) parts.fragment = sections[8].slice(1)\n    return parts\n  }\n  return null\n}\n\nconst EMPTY_RESULT: DIDResolutionResult = {\n  didResolutionMetadata: {},\n  didDocument: null,\n  didDocumentMetadata: {}\n}\n\nexport function wrapLegacyResolver(resolve: LegacyDIDResolver): DIDResolver {\n  return async (did, parsed, resolver) => {\n    try {\n      const doc = await resolve(did, parsed, resolver)\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { contentType: 'application/did+ld+json' },\n        didDocument: doc\n      }\n    } catch (e) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: {\n          error: 'notFound',\n          message: e.toString() // This is not in spec, nut may be helpful\n        }\n      }\n    }\n  }\n}\n\nexport type Resolvable = {\n  resolve: (\n    didUrl: string,\n    options?: DIDResolutionOptions\n  ) => Promise<DIDResolutionResult>\n}\n\nexport class Resolver implements Resolvable {\n  private registry: ResolverRegistry\n  private cache: DIDCache\n\n  constructor(registry: ResolverRegistry = {}, options: ResolverOptions = {}) {\n    this.registry = registry\n    this.cache =\n      options.cache === true ? inMemoryCache() : options.cache || noCache\n    if (options.legacyResolvers) {\n      Object.keys(options.legacyResolvers).map((methodName) => {\n        if (!this.registry[methodName]) {\n          this.registry[methodName] = wrapLegacyResolver(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            options.legacyResolvers![methodName]\n          )\n        }\n      })\n    }\n  }\n\n  async resolve(\n    didUrl: string,\n    options: DIDResolutionOptions = {}\n  ): Promise<DIDResolutionResult> {\n    const parsed = parse(didUrl)\n    if (parsed === null) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { error: 'invalidDid' }\n      }\n    }\n    const resolver = this.registry[parsed.method]\n    if (!resolver) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { error: 'unsupportedDidMethod' }\n      }\n    }\n    return this.cache(parsed, () => resolver(parsed.did, parsed, this, options))\n  }\n}\n"]},"metadata":{},"sourceType":"module"}