{"ast":null,"code":"var _classCallCheck = require(\"C:/not-sync/git2/defiwiki-mono/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/not-sync/git2/defiwiki-mono/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n!function (g, c) {\n  typeof exports == \"object\" && typeof module != \"undefined\" ? c(exports) : typeof define == \"function\" && define.amd ? define([\"exports\"], c) : c((g = g || self).lru_map = g.lru_map || {});\n}(this, function (g) {\n  var c = Symbol(\"newer\"),\n      e = Symbol(\"older\");\n\n  var n = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function n(a, b) {\n      _classCallCheck(this, n);\n\n      typeof a !== \"number\" && (b = a, a = 0), this.size = 0, this.limit = a, this.oldest = this.newest = void 0, this._keymap = new Map(), b && (this.assign(b), a < 1 && (this.limit = this.size));\n    }\n\n    _createClass(n, [{\n      key: \"_markEntryAsUsed\",\n      value: function _markEntryAsUsed(a) {\n        if (a === this.newest) return;\n        a[c] && (a === this.oldest && (this.oldest = a[c]), a[c][e] = a[e]), a[e] && (a[e][c] = a[c]), a[c] = void 0, a[e] = this.newest, this.newest && (this.newest[c] = a), this.newest = a;\n      }\n    }, {\n      key: \"assign\",\n      value: function assign(a) {\n        var b,\n            d = this.limit || Number.MAX_VALUE;\n\n        this._keymap.clear();\n\n        var m = a[Symbol.iterator]();\n\n        for (var h = m.next(); !h.done; h = m.next()) {\n          var f = new l(h.value[0], h.value[1]);\n          this._keymap.set(f.key, f), b ? (b[c] = f, f[e] = b) : this.oldest = f, b = f;\n          if (d-- == 0) throw new Error(\"overflow\");\n        }\n\n        this.newest = b, this.size = this._keymap.size;\n      }\n    }, {\n      key: \"get\",\n      value: function get(a) {\n        var b = this._keymap.get(a);\n\n        return b ? (this._markEntryAsUsed(b), b.value) : void 0;\n      }\n    }, {\n      key: \"set\",\n      value: function set(a, b) {\n        var d = this._keymap.get(a);\n\n        return d ? (d.value = b, this._markEntryAsUsed(d), this) : (this._keymap.set(a, d = new l(a, b)), this.newest ? (this.newest[c] = d, d[e] = this.newest) : this.oldest = d, this.newest = d, ++this.size, this.size > this.limit && this.shift(), this);\n      }\n    }, {\n      key: \"shift\",\n      value: function shift() {\n        var a = this.oldest;\n        if (a) return this.oldest[c] ? (this.oldest = this.oldest[c], this.oldest[e] = void 0) : (this.oldest = void 0, this.newest = void 0), a[c] = a[e] = void 0, this._keymap.delete(a.key), --this.size, [a.key, a.value];\n      }\n    }, {\n      key: \"find\",\n      value: function find(a) {\n        var b = this._keymap.get(a);\n\n        return b ? b.value : void 0;\n      }\n    }, {\n      key: \"has\",\n      value: function has(a) {\n        return this._keymap.has(a);\n      }\n    }, {\n      key: \"delete\",\n      value: function _delete(a) {\n        var b = this._keymap.get(a);\n\n        return b ? (this._keymap.delete(b.key), b[c] && b[e] ? (b[e][c] = b[c], b[c][e] = b[e]) : b[c] ? (b[c][e] = void 0, this.oldest = b[c]) : b[e] ? (b[e][c] = void 0, this.newest = b[e]) : this.oldest = this.newest = void 0, this.size--, b.value) : void 0;\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this.oldest = this.newest = void 0, this.size = 0, this._keymap.clear();\n      }\n    }, {\n      key: \"keys\",\n      value: function keys() {\n        return new j(this.oldest);\n      }\n    }, {\n      key: \"values\",\n      value: function values() {\n        return new k(this.oldest);\n      }\n    }, {\n      key: \"entries\",\n      value: function entries() {\n        return this;\n      }\n    }, {\n      key: Symbol.iterator,\n      value: function value() {\n        return new i(this.oldest);\n      }\n    }, {\n      key: \"forEach\",\n      value: function forEach(a, b) {\n        typeof b !== \"object\" && (b = this);\n        var d = this.oldest;\n\n        for (; d;) {\n          a.call(b, d.value, d.key, this), d = d[c];\n        }\n      }\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        for (var a = new Array(this.size), b = 0, d = this.oldest; d;) {\n          a[b++] = {\n            key: d.key,\n            value: d.value\n          }, d = d[c];\n        }\n\n        return a;\n      }\n    }, {\n      key: \"toString\",\n      value: function toString() {\n        for (var a = \"\", b = this.oldest; b;) {\n          a += String(b.key) + \":\" + b.value, b = b[c], b && (a += \" < \");\n        }\n\n        return a;\n      }\n    }]);\n\n    return n;\n  }();\n\n  g.LRUMap = n;\n\n  function l(a, b) {\n    this.key = a, this.value = b, this[c] = void 0, this[e] = void 0;\n  }\n\n  function i(a) {\n    this.entry = a;\n  }\n\n  i.prototype[Symbol.iterator] = function () {\n    return this;\n  }, i.prototype.next = function () {\n    var a = this.entry;\n    return a ? (this.entry = a[c], {\n      done: !1,\n      value: [a.key, a.value]\n    }) : {\n      done: !0,\n      value: void 0\n    };\n  };\n\n  function j(a) {\n    this.entry = a;\n  }\n\n  j.prototype[Symbol.iterator] = function () {\n    return this;\n  }, j.prototype.next = function () {\n    var a = this.entry;\n    return a ? (this.entry = a[c], {\n      done: !1,\n      value: a.key\n    }) : {\n      done: !0,\n      value: void 0\n    };\n  };\n\n  function k(a) {\n    this.entry = a;\n  }\n\n  k.prototype[Symbol.iterator] = function () {\n    return this;\n  }, k.prototype.next = function () {\n    var a = this.entry;\n    return a ? (this.entry = a[c], {\n      done: !1,\n      value: a.value\n    }) : {\n      done: !0,\n      value: void 0\n    };\n  };\n});","map":{"version":3,"sources":["lru.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\n!function(g,f){\n  if (typeof exports == 'object' && typeof module != \"undefined\") {\n    f(exports)\n  } else if (typeof define == 'function' && define.amd) {\n    define([\"exports\"], f)\n  } else {\n    f((g = g || self)[\"lru_map\"] = (g[\"lru_map\"] || {}))\n  }\n}(this, function(exports) {\n\nconst NEWER = Symbol('newer');\nconst OLDER = Symbol('older');\n\nclass LRUMap {\n  constructor(limit, entries) {\n    if (typeof limit !== 'number') {\n      // called as (entries)\n      entries = limit;\n      limit = 0;\n    }\n\n    this.size = 0;\n    this.limit = limit;\n    this.oldest = this.newest = undefined;\n    this._keymap = new Map();\n\n    if (entries) {\n      this.assign(entries);\n      if (limit < 1) {\n        this.limit = this.size;\n      }\n    }\n  }\n\n  _markEntryAsUsed(entry) {\n    if (entry === this.newest) {\n      // Already the most recenlty used entry, so no need to update the list\n      return;\n    }\n    // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n    if (entry[NEWER]) {\n      if (entry === this.oldest) {\n        this.oldest = entry[NEWER];\n      }\n      entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.\n    }\n    if (entry[OLDER]) {\n      entry[OLDER][NEWER] = entry[NEWER]; // C. --> E\n    }\n    entry[NEWER] = undefined; // D --x\n    entry[OLDER] = this.newest; // D. --> E\n    if (this.newest) {\n      this.newest[NEWER] = entry; // E. <-- D\n    }\n    this.newest = entry;\n  }\n\n  assign(entries) {\n    let entry, limit = this.limit || Number.MAX_VALUE;\n    this._keymap.clear();\n    let it = entries[Symbol.iterator]();\n    for (let itv = it.next(); !itv.done; itv = it.next()) {\n      let e = new Entry(itv.value[0], itv.value[1]);\n      this._keymap.set(e.key, e);\n      if (!entry) {\n        this.oldest = e;\n      } else {\n        entry[NEWER] = e;\n        e[OLDER] = entry;\n      }\n      entry = e;\n      if (limit-- == 0) {\n        throw new Error('overflow');\n      }\n    }\n    this.newest = entry;\n    this.size = this._keymap.size;\n  }\n\n  get(key) {\n    // First, find our cache entry\n    var entry = this._keymap.get(key);\n    if (!entry) return; // Not cached. Sorry.\n    // As <key> was found in the cache, register it as being requested recently\n    this._markEntryAsUsed(entry);\n    return entry.value;\n  }\n\n  set(key, value) {\n    var entry = this._keymap.get(key);\n\n    if (entry) {\n      // update existing\n      entry.value = value;\n      this._markEntryAsUsed(entry);\n      return this;\n    }\n\n    // new entry\n    this._keymap.set(key, (entry = new Entry(key, value)));\n\n    if (this.newest) {\n      // link previous tail to the new tail (entry)\n      this.newest[NEWER] = entry;\n      entry[OLDER] = this.newest;\n    } else {\n      // we're first in -- yay\n      this.oldest = entry;\n    }\n\n    // add new entry to the end of the linked list -- it's now the freshest entry.\n    this.newest = entry;\n    ++this.size;\n    if (this.size > this.limit) {\n      // we hit the limit -- remove the head\n      this.shift();\n    }\n\n    return this;\n  }\n\n  shift() {\n    // todo: handle special case when limit == 1\n    var entry = this.oldest;\n    if (entry) {\n      if (this.oldest[NEWER]) {\n        // advance the list\n        this.oldest = this.oldest[NEWER];\n        this.oldest[OLDER] = undefined;\n      } else {\n        // the cache is exhausted\n        this.oldest = undefined;\n        this.newest = undefined;\n      }\n      // Remove last strong reference to <entry> and remove links from the purged\n      // entry being returned:\n      entry[NEWER] = entry[OLDER] = undefined;\n      this._keymap.delete(entry.key);\n      --this.size;\n      return [entry.key, entry.value];\n    }\n  }\n\n  // -------------------------------------------------------------------------------------\n  // Following code (until end of class definition) is optional and can be removed without\n  // breaking the core functionality.\n\n  find(key) {\n    let e = this._keymap.get(key);\n    return e ? e.value : undefined;\n  }\n\n  has(key) {\n    return this._keymap.has(key);\n  }\n\n  delete(key) {\n    var entry = this._keymap.get(key);\n    if (!entry) return;\n    this._keymap.delete(entry.key);\n    if (entry[NEWER] && entry[OLDER]) {\n      // relink the older entry with the newer entry\n      entry[OLDER][NEWER] = entry[NEWER];\n      entry[NEWER][OLDER] = entry[OLDER];\n    } else if (entry[NEWER]) {\n      // remove the link to us\n      entry[NEWER][OLDER] = undefined;\n      // link the newer entry to head\n      this.oldest = entry[NEWER];\n    } else if (entry[OLDER]) {\n      // remove the link to us\n      entry[OLDER][NEWER] = undefined;\n      // link the newer entry to head\n      this.newest = entry[OLDER];\n    } else {// if(entry[OLDER] === undefined && entry.newer === undefined) {\n      this.oldest = this.newest = undefined;\n    }\n\n    this.size--;\n    return entry.value;\n  }\n\n  clear() {\n    // Not clearing links should be safe, as we don't expose live links to user\n    this.oldest = this.newest = undefined;\n    this.size = 0;\n    this._keymap.clear();\n  }\n\n  keys() {\n    return new KeyIterator(this.oldest);\n  }\n\n  values() {\n    return new ValueIterator(this.oldest);\n  }\n\n  entries() {\n    return this;\n  }\n\n  [Symbol.iterator]() {\n    return new EntryIterator(this.oldest);\n  }\n\n  forEach(fun, thisObj) {\n    if (typeof thisObj !== 'object') {\n      thisObj = this;\n    }\n    let entry = this.oldest;\n    while (entry) {\n      fun.call(thisObj, entry.value, entry.key, this);\n      entry = entry[NEWER];\n    }\n  }\n\n  /** Returns a JSON (array) representation */\n  toJSON() {\n    var s = new Array(this.size), i = 0, entry = this.oldest;\n    while (entry) {\n      s[i++] = { key: entry.key, value: entry.value };\n      entry = entry[NEWER];\n    }\n    return s;\n  }\n\n  /** Returns a String representation */\n  toString() {\n    var s = '', entry = this.oldest;\n    while (entry) {\n      s += String(entry.key)+':'+entry.value;\n      entry = entry[NEWER];\n      if (entry) {\n        s += ' < ';\n      }\n    }\n    return s;\n  }\n}\n\nexports.LRUMap = LRUMap\n\nfunction Entry(key, value) {\n  this.key = key;\n  this.value = value;\n  this[NEWER] = undefined;\n  this[OLDER] = undefined;\n}\n\n\nfunction EntryIterator(oldestEntry) { this.entry = oldestEntry; }\nEntryIterator.prototype[Symbol.iterator] = function() { return this; }\nEntryIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: [ent.key, ent.value] };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n\nfunction KeyIterator(oldestEntry) { this.entry = oldestEntry; }\nKeyIterator.prototype[Symbol.iterator] = function() { return this; }\nKeyIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.key };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\nfunction ValueIterator(oldestEntry) { this.entry = oldestEntry; }\nValueIterator.prototype[Symbol.iterator] = function() { return this; }\nValueIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.value };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n});\n"]},"metadata":{},"sourceType":"script"}