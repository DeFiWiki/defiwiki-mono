{"ast":null,"code":"import _toConsumableArray from \"C:/not-sync/git2/defiwiki-mono/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"C:/not-sync/git2/defiwiki-mono/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport * as u8a from 'uint8arrays';\nimport { hash } from '@stablelib/sha256';\nimport { keccak_256 } from 'js-sha3';\nimport { ec } from 'elliptic';\nimport { sign, verify } from '@stablelib/ed25519';\nimport canonicalizeData from 'canonicalize';\nimport { sharedKey, generateKeyPair } from '@stablelib/x25519';\nimport { XChaCha20Poly1305 } from '@stablelib/xchacha20poly1305';\nimport { randomBytes } from '@stablelib/random';\n\nfunction bytesToBase64url(b) {\n  return u8a.toString(b, 'base64url');\n}\n\nfunction base64ToBytes(s) {\n  var inputBase64Url = s.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n  return u8a.fromString(inputBase64Url, 'base64url');\n}\n\nfunction base58ToBytes(s) {\n  return u8a.fromString(s, 'base58btc');\n}\n\nfunction hexToBytes(s) {\n  var input = s.startsWith('0x') ? s.substring(2) : s;\n  return u8a.fromString(input.toLowerCase(), 'base16');\n}\n\nfunction encodeBase64url(s) {\n  return bytesToBase64url(u8a.fromString(s));\n}\n\nfunction decodeBase64url(s) {\n  return u8a.toString(base64ToBytes(s));\n}\n\nfunction bytesToHex(b) {\n  return u8a.toString(b, 'base16');\n}\n\nfunction stringToBytes(s) {\n  return u8a.fromString(s);\n}\n\nfunction toJose(_ref, recoverable) {\n  var r = _ref.r,\n      s = _ref.s,\n      recoveryParam = _ref.recoveryParam;\n  var jose = new Uint8Array(recoverable ? 65 : 64);\n  jose.set(u8a.fromString(r, 'base16'), 0);\n  jose.set(u8a.fromString(s, 'base16'), 32);\n\n  if (recoverable) {\n    if (typeof recoveryParam === 'undefined') {\n      throw new Error('Signer did not return a recoveryParam');\n    }\n\n    jose[64] = recoveryParam;\n  }\n\n  return bytesToBase64url(jose);\n}\n\nfunction fromJose(signature) {\n  var signatureBytes = base64ToBytes(signature);\n\n  if (signatureBytes.length < 64 || signatureBytes.length > 65) {\n    throw new TypeError(\"Wrong size for signature. Expected 64 or 65 bytes, but got \".concat(signatureBytes.length));\n  }\n\n  var r = bytesToHex(signatureBytes.slice(0, 32));\n  var s = bytesToHex(signatureBytes.slice(32, 64));\n  var recoveryParam = signatureBytes.length === 65 ? signatureBytes[64] : undefined;\n  return {\n    r: r,\n    s: s,\n    recoveryParam: recoveryParam\n  };\n}\n\nfunction toSealed(ciphertext, tag) {\n  return u8a.concat([base64ToBytes(ciphertext), base64ToBytes(tag)]);\n}\n\nvar hexMatcher = /^(0x)?([a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/;\nvar base58Matcher = /^([1-9A-HJ-NP-Za-km-z]{44}|[1-9A-HJ-NP-Za-km-z]{88})$/;\nvar base64Matcher = /^([0-9a-zA-Z=\\-_+/]{43}|[0-9a-zA-Z=\\-_+/]{86})(={0,2})$/;\n/**\r\n * Parses a private key and returns the Uint8Array representation.\r\n * This method uses an heuristic to determine the key encoding to then be able to parse it into 32 or 64 bytes.\r\n *\r\n * @param input a 32 or 64 byte key presented either as a Uint8Array or as a hex, base64, or base58btc encoded string\r\n *\r\n * @throws TypeError('Invalid private key format') if the key doesn't match any of the accepted formats or length\r\n */\n\nfunction parseKey(input) {\n  if (typeof input === 'string') {\n    if (hexMatcher.test(input)) {\n      return hexToBytes(input);\n    } else if (base58Matcher.test(input)) {\n      return base58ToBytes(input);\n    } else if (base64Matcher.test(input)) {\n      return base64ToBytes(input);\n    } else {\n      throw TypeError('bad_key: Invalid private key format');\n    }\n  } else if (input instanceof Uint8Array) {\n    return input;\n  } else {\n    throw TypeError('bad_key: Invalid private key format');\n  }\n}\n\nfunction leftpad(data) {\n  var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;\n  if (data.length === size) return data;\n  return '0'.repeat(size - data.length) + data;\n}\n\nfunction sha256(payload) {\n  var data = typeof payload === 'string' ? u8a.fromString(payload) : payload;\n  return hash(data);\n}\n\nfunction keccak(data) {\n  return new Uint8Array(keccak_256.arrayBuffer(data));\n}\n\nfunction toEthereumAddress(hexPublicKey) {\n  var hashInput = u8a.fromString(hexPublicKey.slice(2), 'base16');\n  return \"0x\".concat(u8a.toString(keccak(hashInput).slice(-20), 'base16'));\n}\n\nfunction writeUint32BE(value) {\n  var array = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Uint8Array(4);\n  var encoded = u8a.fromString(value.toString(), 'base10');\n  array.set(encoded, 4 - encoded.length);\n  return array;\n}\n\nvar lengthAndInput = function lengthAndInput(input) {\n  return u8a.concat([writeUint32BE(input.length), input]);\n}; // This implementation of concatKDF was inspired by these two implementations:\n// https://github.com/digitalbazaar/minimal-cipher/blob/master/algorithms/ecdhkdf.js\n// https://github.com/panva/jose/blob/master/lib/jwa/ecdh/derive.js\n\n\nfunction concatKDF(secret, keyLen, alg, producerInfo, consumerInfo) {\n  if (keyLen !== 256) throw new Error(\"Unsupported key length: \".concat(keyLen));\n  var value = u8a.concat([lengthAndInput(u8a.fromString(alg)), lengthAndInput(typeof producerInfo === 'undefined' ? new Uint8Array(0) : producerInfo), lengthAndInput(typeof consumerInfo === 'undefined' ? new Uint8Array(0) : consumerInfo), writeUint32BE(keyLen)]); // since our key lenght is 256 we only have to do one round\n\n  var roundNumber = 1;\n  return hash(u8a.concat([writeUint32BE(roundNumber), secret, value]));\n}\n\nvar secp256k1$1 = new ec('secp256k1');\n/**\r\n *  Creates a configured signer function for signing data using the ES256K (secp256k1 + sha256) algorithm.\r\n *\r\n *  The signing function itself takes the data as a `Uint8Array` or `string` and returns a `base64Url`-encoded signature\r\n *\r\n *  @example\r\n *  ```typescript\r\n *  const sign: Signer = ES256KSigner(process.env.PRIVATE_KEY)\r\n *  const signature: string = await sign(data)\r\n *  ```\r\n *\r\n *  @param    {String}    privateKey   a private key as `Uint8Array` or encoded as `base64`, `base58`, or `hex` string\r\n *  @param    {Boolean}   recoverable  an optional flag to add the recovery param to the generated signatures\r\n *  @return   {Function}               a configured signer function `(data: string | Uint8Array): Promise<string>`\r\n */\n\nfunction ES256KSigner(privateKey) {\n  var recoverable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var privateKeyBytes = parseKey(privateKey);\n\n  if (privateKeyBytes.length !== 32) {\n    throw new Error(\"bad_key: Invalid private key format. Expecting 32 bytes, but got \".concat(privateKeyBytes.length));\n  }\n\n  var keyPair = secp256k1$1.keyFromPrivate(privateKeyBytes);\n  return function (data) {\n    try {\n      var _keyPair$sign = keyPair.sign(sha256(data)),\n          r = _keyPair$sign.r,\n          s = _keyPair$sign.s,\n          recoveryParam = _keyPair$sign.recoveryParam;\n\n      return Promise.resolve(toJose({\n        r: leftpad(r.toString('hex')),\n        s: leftpad(s.toString('hex')),\n        recoveryParam: recoveryParam\n      }, recoverable));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n/**\r\n * @deprecated Please use ES256KSigner\r\n *  The SimpleSigner returns a configured function for signing data.\r\n *\r\n *  @example\r\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\r\n *  signer(data, (err, signature) => {\r\n *    ...\r\n *  })\r\n *\r\n *  @param    {String}         hexPrivateKey    a hex encoded private key\r\n *  @return   {Function}                     a configured signer function\r\n */\n\n\nfunction SimpleSigner(hexPrivateKey) {\n  var signer = ES256KSigner(hexPrivateKey, true);\n  return function (data) {\n    try {\n      return Promise.resolve(signer(data)).then(fromJose);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n/**\r\n * @deprecated Please use ES256KSigner\r\n *  The EllipticSigner returns a configured function for signing data.\r\n *\r\n *  @example\r\n *  ```typescript\r\n *  const signer = EllipticSigner(process.env.PRIVATE_KEY)\r\n *  signer(data).then( (signature: string) => {\r\n *    ...\r\n *  })\r\n *  ```\r\n *\r\n *  @param    {String}         hexPrivateKey    a hex encoded private key\r\n *  @return   {Function}                        a configured signer function\r\n */\n\n\nfunction EllipticSigner(hexPrivateKey) {\n  return ES256KSigner(hexPrivateKey);\n}\n/**\r\n *  Creates a configured signer function for signing data using the EdDSA (Ed25519) algorithm.\r\n *\r\n *  The signing function itself takes the data as a `Uint8Array` or `string` and returns a `base64Url`-encoded signature\r\n *\r\n *  @example\r\n *  ```typescript\r\n *  const sign: Signer = EdDSASigner(process.env.PRIVATE_KEY)\r\n *  const signature: string = await sign(data)\r\n *  ```\r\n *\r\n *  @param    {String}    secretKey   a 64 byte secret key as `Uint8Array` or encoded as `base64`, `base58`, or `hex` string\r\n *  @return   {Function}              a configured signer function `(data: string | Uint8Array): Promise<string>`\r\n */\n\n\nfunction EdDSASigner(secretKey) {\n  var privateKeyBytes = parseKey(secretKey);\n\n  if (privateKeyBytes.length !== 64) {\n    throw new Error(\"bad_key: Invalid private key format. Expecting 64 bytes, but got \".concat(privateKeyBytes.length));\n  }\n\n  return function (data) {\n    try {\n      var dataBytes = typeof data === 'string' ? stringToBytes(data) : data;\n      var sig = sign(privateKeyBytes, dataBytes);\n      return Promise.resolve(bytesToBase64url(sig));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n/**\r\n * @deprecated Please use EdDSASigner\r\n *\r\n *  The NaclSigner returns a configured function for signing data using the Ed25519 algorithm.\r\n *\r\n *  The signing function itself takes the data as a `string` or `Uint8Array` parameter and returns a `base64Url`-encoded signature.\r\n *\r\n *  @example\r\n *  const signer = NaclSigner(process.env.PRIVATE_KEY)\r\n *  const data: string = '...'\r\n *  signer(data).then( (signature: string) => {\r\n *    ...\r\n *  })\r\n *\r\n *  @param    {String}   base64PrivateKey    a 64 byte base64 encoded private key\r\n *  @return   {Function}                     a configured signer function\r\n */\n\n\nfunction NaclSigner(base64PrivateKey) {\n  return EdDSASigner(base64PrivateKey);\n}\n\nfunction instanceOfEcdsaSignature(object) {\n  return typeof object === 'object' && 'r' in object && 's' in object;\n}\n\nfunction ES256KSignerAlg(recoverable) {\n  return function sign(payload, signer) {\n    try {\n      return Promise.resolve(signer(payload)).then(function (signature) {\n        if (instanceOfEcdsaSignature(signature)) {\n          return toJose(signature, recoverable);\n        } else {\n          if (recoverable && typeof fromJose(signature).recoveryParam === 'undefined') {\n            throw new Error(\"not_supported: ES256K-R not supported when signer doesn't provide a recovery param\");\n          }\n\n          return signature;\n        }\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nfunction Ed25519SignerAlg() {\n  return function sign(payload, signer) {\n    try {\n      return Promise.resolve(signer(payload)).then(function (signature) {\n        if (!instanceOfEcdsaSignature(signature)) {\n          return signature;\n        } else {\n          throw new Error('invalid_config: expected a signer function that returns a string instead of signature object');\n        }\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nvar algorithms$1 = {\n  ES256K: ES256KSignerAlg(),\n  // This is a non-standard algorithm but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/146\n  'ES256K-R': ES256KSignerAlg(true),\n  // This is actually incorrect but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/130\n  Ed25519: Ed25519SignerAlg(),\n  EdDSA: Ed25519SignerAlg()\n};\n\nfunction SignerAlg(alg) {\n  var impl = algorithms$1[alg];\n  if (!impl) throw new Error(\"not_supported: Unsupported algorithm \".concat(alg));\n  return impl;\n}\n\nvar secp256k1 = new ec('secp256k1'); // converts a JOSE signature to it's components\n\nfunction toSignatureObject(signature) {\n  var recoverable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var rawSig = base64ToBytes(signature);\n\n  if (rawSig.length !== (recoverable ? 65 : 64)) {\n    throw new Error('wrong signature length');\n  }\n\n  var r = bytesToHex(rawSig.slice(0, 32));\n  var s = bytesToHex(rawSig.slice(32, 64));\n  var sigObj = {\n    r: r,\n    s: s\n  };\n\n  if (recoverable) {\n    sigObj.recoveryParam = rawSig[64];\n  }\n\n  return sigObj;\n}\n\nfunction extractPublicKeyBytes(pk) {\n  if (pk.publicKeyBase58) {\n    return base58ToBytes(pk.publicKeyBase58);\n  } else if (pk.publicKeyBase64) {\n    return base64ToBytes(pk.publicKeyBase64);\n  } else if (pk.publicKeyHex) {\n    return hexToBytes(pk.publicKeyHex);\n  } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === 'secp256k1' && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {\n    return hexToBytes(secp256k1.keyFromPublic({\n      x: bytesToHex(base64ToBytes(pk.publicKeyJwk.x)),\n      y: bytesToHex(base64ToBytes(pk.publicKeyJwk.y))\n    }).getPublic('hex'));\n  }\n\n  return new Uint8Array();\n}\n\nfunction verifyES256K(data, signature, authenticators) {\n  var hash = sha256(data);\n  var sigObj = toSignatureObject(signature);\n  var fullPublicKeys = authenticators.filter(function (_ref2) {\n    var ethereumAddress = _ref2.ethereumAddress,\n        blockchainAccountId = _ref2.blockchainAccountId;\n    return typeof ethereumAddress === 'undefined' && typeof blockchainAccountId === 'undefined';\n  });\n  var ethAddressKeys = authenticators.filter(function (_ref3) {\n    var ethereumAddress = _ref3.ethereumAddress,\n        blockchainAccountId = _ref3.blockchainAccountId;\n    return typeof ethereumAddress !== 'undefined' || typeof blockchainAccountId !== undefined;\n  });\n  var signer = fullPublicKeys.find(function (pk) {\n    try {\n      var pubBytes = extractPublicKeyBytes(pk);\n      return secp256k1.keyFromPublic(pubBytes).verify(hash, sigObj);\n    } catch (err) {\n      return false;\n    }\n  });\n\n  if (!signer && ethAddressKeys.length > 0) {\n    signer = verifyRecoverableES256K(data, signature, ethAddressKeys);\n  }\n\n  if (!signer) throw new Error('invalid_signature: Signature invalid for JWT');\n  return signer;\n}\n\nfunction verifyRecoverableES256K(data, signature, authenticators) {\n  var signatures;\n\n  if (signature.length > 86) {\n    signatures = [toSignatureObject(signature, true)];\n  } else {\n    var so = toSignatureObject(signature, false);\n    signatures = [_objectSpread(_objectSpread({}, so), {}, {\n      recoveryParam: 0\n    }), _objectSpread(_objectSpread({}, so), {}, {\n      recoveryParam: 1\n    })];\n  }\n\n  var checkSignatureAgainstSigner = function checkSignatureAgainstSigner(sigObj) {\n    var hash = sha256(data); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    var recoveredKey = secp256k1.recoverPubKey(hash, sigObj, sigObj.recoveryParam);\n    var recoveredPublicKeyHex = recoveredKey.encode('hex');\n    var recoveredCompressedPublicKeyHex = recoveredKey.encode('hex', true);\n    var recoveredAddress = toEthereumAddress(recoveredPublicKeyHex);\n    var signer = authenticators.find(function (pk) {\n      var _pk$ethereumAddress, _pk$blockchainAccount, _pk$blockchainAccount2;\n\n      var keyHex = bytesToHex(extractPublicKeyBytes(pk));\n      return keyHex === recoveredPublicKeyHex || keyHex === recoveredCompressedPublicKeyHex || ((_pk$ethereumAddress = pk.ethereumAddress) == null ? void 0 : _pk$ethereumAddress.toLowerCase()) === recoveredAddress || ((_pk$blockchainAccount = pk.blockchainAccountId) == null ? void 0 : (_pk$blockchainAccount2 = _pk$blockchainAccount.split('@eip155')) == null ? void 0 : _pk$blockchainAccount2[0].toLowerCase()) === recoveredAddress;\n    });\n    return signer;\n  };\n\n  var signer = signatures.map(checkSignatureAgainstSigner).filter(function (key) {\n    return typeof key !== 'undefined';\n  });\n  if (signer.length === 0) throw new Error('invalid_signature: Signature invalid for JWT');\n  return signer[0];\n}\n\nfunction verifyEd25519(data, signature, authenticators) {\n  var clear = stringToBytes(data);\n  var sig = base64ToBytes(signature);\n  var signer = authenticators.find(function (pk) {\n    return verify(extractPublicKeyBytes(pk), clear, sig);\n  });\n  if (!signer) throw new Error('invalid_signature: Signature invalid for JWT');\n  return signer;\n}\n\nvar algorithms = {\n  ES256K: verifyES256K,\n  // This is a non-standard algorithm but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/146\n  'ES256K-R': verifyRecoverableES256K,\n  // This is actually incorrect but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/130\n  Ed25519: verifyEd25519,\n  EdDSA: verifyEd25519\n};\n\nfunction VerifierAlgorithm(alg) {\n  var impl = algorithms[alg];\n  if (!impl) throw new Error(\"not_supported: Unsupported algorithm \".concat(alg));\n  return impl;\n}\n\nVerifierAlgorithm.toSignatureObject = toSignatureObject;\n/**\r\n * Resolves relevant public keys or other authenticating material used to verify signature from the DID document of provided DID\r\n *\r\n *  @example\r\n *  resolveAuthenticator(resolver, 'ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {\r\n *      const payload = obj.payload\r\n *      const profile = obj.profile\r\n *      const jwt = obj.jwt\r\n *      ...\r\n *  })\r\n *\r\n *  @param    {String}            alg                a JWT algorithm\r\n *  @param    {String}            did                a Decentralized IDentifier (DID) to lookup\r\n *  @param    {Boolean}           auth               Restrict public keys to ones specifically listed in the 'authentication' section of DID document\r\n *  @return   {Promise<DIDAuthenticator>}               a promise which resolves with a response object containing an array of authenticators or if non exist rejects with an error\r\n */\n\nvar resolveAuthenticator = function resolveAuthenticator(resolver, alg, issuer, proofPurpose) {\n  try {\n    var types = SUPPORTED_PUBLIC_KEY_TYPES[alg];\n\n    if (!types || types.length === 0) {\n      throw new Error(\"not_supported: No supported signature types for algorithm \".concat(alg));\n    }\n\n    var didResult;\n    return Promise.resolve(resolver.resolve(issuer, {\n      accept: DID_JSON\n    })).then(function (result) {\n      var _didResult$didResolut, _didResult, _didResult$didDocumen, _didResult2, _didResult2$didDocume; // support legacy resolvers that do not produce DIDResolutionResult\n\n\n      if (Object.getOwnPropertyNames(result).indexOf('didDocument') === -1) {\n        didResult = {\n          didDocument: result,\n          didDocumentMetadata: {},\n          didResolutionMetadata: {\n            contentType: DID_JSON\n          }\n        };\n      } else {\n        didResult = result;\n      }\n\n      if ((_didResult$didResolut = didResult.didResolutionMetadata) != null && _didResult$didResolut.error || didResult.didDocument == null) {\n        var _didResult$didResolut2 = didResult.didResolutionMetadata,\n            error = _didResult$didResolut2.error,\n            message = _didResult$didResolut2.message;\n        throw new Error(\"resolver_error: Unable to resolve DID document for \".concat(issuer, \": \").concat(error, \", \").concat(message || ''));\n      }\n\n      var getPublicKeyById = function getPublicKeyById(verificationMethods, pubid) {\n        var filtered = verificationMethods.filter(function (_ref4) {\n          var id = _ref4.id;\n          return pubid === id;\n        });\n        return filtered.length > 0 ? filtered[0] : null;\n      };\n\n      var publicKeysToCheck = [].concat(_toConsumableArray(((_didResult = didResult) == null ? void 0 : (_didResult$didDocumen = _didResult.didDocument) == null ? void 0 : _didResult$didDocumen.verificationMethod) || []), _toConsumableArray(((_didResult2 = didResult) == null ? void 0 : (_didResult2$didDocume = _didResult2.didDocument) == null ? void 0 : _didResult2$didDocume.publicKey) || []));\n\n      if (typeof proofPurpose === 'string') {\n        var _didResult3; // support legacy DID Documents that do not list assertionMethod\n\n\n        if (proofPurpose.startsWith('assertion') && !Object.getOwnPropertyNames((_didResult3 = didResult) == null ? void 0 : _didResult3.didDocument).includes('assertionMethod')) {\n          didResult.didDocument = _objectSpread({}, didResult.didDocument);\n          didResult.didDocument.assertionMethod = _toConsumableArray(publicKeysToCheck.map(function (pk) {\n            return pk.id;\n          }));\n        }\n\n        publicKeysToCheck = (didResult.didDocument[proofPurpose] || []).map(function (verificationMethod) {\n          if (typeof verificationMethod === 'string') {\n            return getPublicKeyById(publicKeysToCheck, verificationMethod);\n          } else if (typeof verificationMethod.publicKey === 'string') {\n            // this is a legacy format\n            return getPublicKeyById(publicKeysToCheck, verificationMethod.publicKey);\n          } else {\n            return verificationMethod;\n          }\n        }).filter(function (key) {\n          return key != null;\n        });\n      }\n\n      var authenticators = publicKeysToCheck.filter(function (_ref5) {\n        var type = _ref5.type;\n        return types.find(function (supported) {\n          return supported === type;\n        });\n      });\n\n      if (typeof proofPurpose === 'string' && (!authenticators || authenticators.length === 0)) {\n        throw new Error(\"no_suitable_keys: DID document for \".concat(issuer, \" does not have public keys suitable for \").concat(alg, \" with \").concat(proofPurpose, \" purpose\"));\n      }\n\n      if (!authenticators || authenticators.length === 0) {\n        throw new Error(\"no_suitable_keys: DID document for \".concat(issuer, \" does not have public keys for \").concat(alg));\n      }\n\n      return {\n        authenticators: authenticators,\n        issuer: issuer,\n        didResolutionResult: didResult\n      };\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n/**\r\n *  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,\r\n *  and the did doc of the issuer of the JWT.\r\n *\r\n *  @example\r\n *  verifyJWT('did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...'}).then(obj => {\r\n *      const did = obj.did // DID of signer\r\n *      const payload = obj.payload\r\n *      const doc = obj.doc // DID Document of signer\r\n *      const jwt = obj.jwt\r\n *      const signerKeyId = obj.signerKeyId // ID of key in DID document that signed JWT\r\n *      ...\r\n *  })\r\n *\r\n *  @param    {String}            jwt                a JSON Web Token to verify\r\n *  @param    {Object}            [options]           an unsigned credential object\r\n *  @param    {Boolean}           options.auth        Require signer to be listed in the authentication section of the DID document (for Authentication purposes)\r\n *  @param    {String}            options.audience    DID of the recipient of the JWT\r\n *  @param    {String}            options.callbackUrl callback url in JWT\r\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an error\r\n */\n\n\nvar verifyJWT = function verifyJWT(jwt) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    resolver: undefined,\n    auth: undefined,\n    audience: undefined,\n    callbackUrl: undefined,\n    skewTime: undefined,\n    proofPurpose: undefined\n  };\n\n  try {\n    if (!options.resolver) throw new Error('missing_resolver: No DID resolver has been configured');\n\n    var _decodeJWT = decodeJWT(jwt),\n        payload = _decodeJWT.payload,\n        header = _decodeJWT.header,\n        signature = _decodeJWT.signature,\n        data = _decodeJWT.data;\n\n    var proofPurpose = Object.prototype.hasOwnProperty.call(options, 'auth') ? options.auth ? 'authentication' : undefined : options.proofPurpose;\n    return Promise.resolve(resolveAuthenticator(options.resolver, header.alg, payload.iss || '', proofPurpose)).then(function (_ref6) {\n      var didResolutionResult = _ref6.didResolutionResult,\n          authenticators = _ref6.authenticators,\n          issuer = _ref6.issuer;\n      return Promise.resolve(verifyJWSDecoded({\n        header: header,\n        data: data,\n        signature: signature\n      }, authenticators)).then(function (signer) {\n        var now = Math.floor(Date.now() / 1000);\n        var skewTime = typeof options.skewTime !== 'undefined' && options.skewTime >= 0 ? options.skewTime : NBF_SKEW;\n\n        if (signer) {\n          var nowSkewed = now + skewTime;\n\n          if (payload.nbf) {\n            if (payload.nbf > nowSkewed) {\n              throw new Error(\"invalid_jwt: JWT not valid before nbf: \".concat(payload.nbf));\n            }\n          } else if (payload.iat && payload.iat > nowSkewed) {\n            throw new Error(\"invalid_jwt: JWT not valid yet (issued in the future) iat: \".concat(payload.iat));\n          }\n\n          if (payload.exp && payload.exp <= now - skewTime) {\n            throw new Error(\"invalid_jwt: JWT has expired: exp: \".concat(payload.exp, \" < now: \").concat(now));\n          }\n\n          if (payload.aud) {\n            if (!options.audience && !options.callbackUrl) {\n              throw new Error('invalid_config: JWT audience is required but your app address has not been configured');\n            }\n\n            var audArray = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n            var matchedAudience = audArray.find(function (item) {\n              return options.audience === item || options.callbackUrl === item;\n            });\n\n            if (typeof matchedAudience === 'undefined') {\n              throw new Error(\"invalid_config: JWT audience does not match your DID or callback url\");\n            }\n          }\n\n          return {\n            payload: payload,\n            didResolutionResult: didResolutionResult,\n            issuer: issuer,\n            signer: signer,\n            jwt: jwt\n          };\n        }\n\n        throw new Error(\"invalid_signature: JWT not valid. issuer DID document does not contain a verificationMethod that matches the signature.\");\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n/**\r\n *  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is over.\r\n *\r\n *  @example\r\n *  const signer = ES256KSigner(process.env.PRIVATE_KEY)\r\n *  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {\r\n *      ...\r\n *  })\r\n *\r\n *  @param    {Object}            payload               payload object\r\n *  @param    {Object}            [options]             an unsigned credential object\r\n *  @param    {String}            options.issuer        The DID of the issuer (signer) of JWT\r\n *  @param    {String}            options.alg           [DEPRECATED] The JWT signing algorithm to use. Supports: [ES256K, ES256K-R, Ed25519, EdDSA], Defaults to: ES256K.\r\n *                                                      Please use `header.alg` to specify the algorithm\r\n *  @param    {Signer}            options.signer        a `Signer` function, Please see `ES256KSigner` or `EdDSASigner`\r\n *  @param    {boolean}           options.canonicalize  optional flag to canonicalize header and payload before signing\r\n *  @param    {Object}            header                optional object to specify or customize the JWT header\r\n *  @return   {Promise<Object, Error>}                  a promise which resolves with a signed JSON Web Token or rejects with an error\r\n */\n\n\nvar createJWT = function createJWT(payload, _ref7) {\n  var issuer = _ref7.issuer,\n      signer = _ref7.signer,\n      alg = _ref7.alg,\n      expiresIn = _ref7.expiresIn,\n      canonicalize = _ref7.canonicalize;\n  var header = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  try {\n    if (!signer) throw new Error('missing_signer: No Signer functionality has been configured');\n    if (!issuer) throw new Error('missing_issuer: No issuing DID has been configured');\n    if (!header.typ) header.typ = 'JWT';\n    if (!header.alg) header.alg = alg;\n    var timestamps = {\n      iat: Math.floor(Date.now() / 1000),\n      exp: undefined\n    };\n\n    if (expiresIn) {\n      if (typeof expiresIn === 'number') {\n        timestamps.exp = (payload.nbf || timestamps.iat) + Math.floor(expiresIn);\n      } else {\n        throw new Error('invalid_argument: JWT expiresIn is not a number');\n      }\n    }\n\n    var fullPayload = _objectSpread(_objectSpread(_objectSpread({}, timestamps), payload), {}, {\n      iss: issuer\n    });\n\n    return createJWS(fullPayload, signer, header, {\n      canonicalize: canonicalize\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n/**\r\n *  Creates a signed JWS given a payload, a signer, and an optional header.\r\n *\r\n *  @example\r\n *  const signer = ES256KSigner(process.env.PRIVATE_KEY)\r\n *  const jws = await createJWS({ my: 'payload' }, signer)\r\n *\r\n *  @param    {Object}            payload           payload object\r\n *  @param    {Signer}            signer            a signer, see `ES256KSigner or `EdDSASigner`\r\n *  @param    {Object}            header            optional object to specify or customize the JWS header\r\n *  @return   {Promise<Object, Error>}              a promise which resolves with a JWS string or rejects with an error\r\n */\n\n\nvar createJWS = function createJWS(payload, signer) {\n  var header = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  try {\n    if (!header.alg) header.alg = defaultAlg;\n    var encodedPayload = typeof payload === 'string' ? payload : encodeSection(payload, options.canonicalize);\n    var signingInput = [encodeSection(header, options.canonicalize), encodedPayload].join('.');\n    var jwtSigner = SignerAlg(header.alg);\n    return Promise.resolve(jwtSigner(signingInput, signer)).then(function (signature) {\n      return [signingInput, signature].join('.');\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar SUPPORTED_PUBLIC_KEY_TYPES = {\n  ES256K: ['EcdsaSecp256k1VerificationKey2019',\n  /**\r\n   * Equivalent to EcdsaSecp256k1VerificationKey2019 when key is an ethereumAddress\r\n   */\n  'EcdsaSecp256k1RecoveryMethod2020',\n  /**\r\n   * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\r\n   */\n  'Secp256k1VerificationKey2018',\n  /**\r\n   * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\r\n   */\n  'Secp256k1SignatureVerificationKey2018',\n  /**\r\n   * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\r\n   */\n  'EcdsaPublicKeySecp256k1'],\n  'ES256K-R': ['EcdsaSecp256k1VerificationKey2019',\n  /**\r\n   * Equivalent to EcdsaSecp256k1VerificationKey2019 when key is an ethereumAddress\r\n   */\n  'EcdsaSecp256k1RecoveryMethod2020',\n  /**\r\n   * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\r\n   */\n  'Secp256k1VerificationKey2018',\n  /**\r\n   * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\r\n   */\n  'Secp256k1SignatureVerificationKey2018',\n  /**\r\n   * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\r\n   */\n  'EcdsaPublicKeySecp256k1'],\n  Ed25519: ['ED25519SignatureVerification', 'Ed25519VerificationKey2018'],\n  EdDSA: ['ED25519SignatureVerification', 'Ed25519VerificationKey2018']\n};\nvar defaultAlg = 'ES256K';\nvar DID_JSON = 'application/did+json'; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nfunction encodeSection(data) {\n  var shouldCanonicalize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (shouldCanonicalize) {\n    return encodeBase64url(canonicalizeData(data));\n  } else {\n    return encodeBase64url(JSON.stringify(data));\n  }\n}\n\nvar NBF_SKEW = 300;\n\nfunction decodeJWS(jws) {\n  var parts = jws.match(/^([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)$/);\n\n  if (parts) {\n    return {\n      header: JSON.parse(decodeBase64url(parts[1])),\n      payload: parts[2],\n      signature: parts[3],\n      data: \"\".concat(parts[1], \".\").concat(parts[2])\n    };\n  }\n\n  throw new Error('invalid_argument: Incorrect format JWS');\n}\n/**  @module did-jwt/JWT */\n\n/**\r\n *  Decodes a JWT and returns an object representing the payload\r\n *\r\n *  @example\r\n *  decodeJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpYXQiOjE1...')\r\n *\r\n *  @param    {String}            jwt                a JSON Web Token to verify\r\n *  @return   {Object}                               a JS object representing the decoded JWT\r\n */\n\n\nfunction decodeJWT(jwt) {\n  if (!jwt) throw new Error('invalid_argument: no JWT passed into decodeJWT');\n\n  try {\n    var jws = decodeJWS(jwt);\n    var decodedJwt = Object.assign(jws, {\n      payload: JSON.parse(decodeBase64url(jws.payload))\n    });\n    return decodedJwt;\n  } catch (e) {\n    throw new Error('invalid_argument: Incorrect format JWT');\n  }\n}\n\nfunction verifyJWSDecoded(_ref8, pubKeys) {\n  var header = _ref8.header,\n      data = _ref8.data,\n      signature = _ref8.signature;\n  if (!Array.isArray(pubKeys)) pubKeys = [pubKeys];\n  var signer = VerifierAlgorithm(header.alg)(data, signature, pubKeys);\n  return signer;\n}\n/**\r\n *  Verifies given JWS. If the JWS is valid, returns the public key that was\r\n *  used to sign the JWS, or throws an `Error` if none of the `pubKeys` match.\r\n *\r\n *  @example\r\n *  const pubKey = verifyJWS('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', { publicKeyHex: '0x12341...' })\r\n *\r\n *  @param    {String}                          jws         A JWS string to verify\r\n *  @param    {Array<VerificationMethod> | VerificationMethod}    pubKeys     The public keys used to verify the JWS\r\n *  @return   {VerificationMethod}                       The public key used to sign the JWS\r\n */\n\n\nfunction verifyJWS(jws, pubKeys) {\n  var jwsDecoded = decodeJWS(jws);\n  return verifyJWSDecoded(jwsDecoded, pubKeys);\n}\n\nfunction _for(test, update, body) {\n  var stage;\n\n  for (;;) {\n    var shouldContinue = test();\n\n    if (_isSettledPact(shouldContinue)) {\n      shouldContinue = shouldContinue.v;\n    }\n\n    if (!shouldContinue) {\n      return result;\n    }\n\n    if (shouldContinue.then) {\n      stage = 0;\n      break;\n    }\n\n    var result = body();\n\n    if (result && result.then) {\n      if (_isSettledPact(result)) {\n        result = result.s;\n      } else {\n        stage = 1;\n        break;\n      }\n    }\n\n    if (update) {\n      var updateValue = update();\n\n      if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n        stage = 2;\n        break;\n      }\n    }\n  }\n\n  var pact = new _Pact();\n\n  var reject = _settle.bind(null, pact, 2);\n\n  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n  return pact;\n\n  function _resumeAfterBody(value) {\n    result = value;\n\n    do {\n      if (update) {\n        updateValue = update();\n\n        if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n          updateValue.then(_resumeAfterUpdate).then(void 0, reject);\n          return;\n        }\n      }\n\n      shouldContinue = test();\n\n      if (!shouldContinue || _isSettledPact(shouldContinue) && !shouldContinue.v) {\n        _settle(pact, 1, result);\n\n        return;\n      }\n\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n        return;\n      }\n\n      result = body();\n\n      if (_isSettledPact(result)) {\n        result = result.v;\n      }\n    } while (!result || !result.then);\n\n    result.then(_resumeAfterBody).then(void 0, reject);\n  }\n\n  function _resumeAfterTest(shouldContinue) {\n    if (shouldContinue) {\n      result = body();\n\n      if (result && result.then) {\n        result.then(_resumeAfterBody).then(void 0, reject);\n      } else {\n        _resumeAfterBody(result);\n      }\n    } else {\n      _settle(pact, 1, result);\n    }\n  }\n\n  function _resumeAfterUpdate() {\n    if (shouldContinue = test()) {\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n      } else {\n        _resumeAfterTest(shouldContinue);\n      }\n    } else {\n      _settle(pact, 1, result);\n    }\n  }\n}\n\nvar decryptJWE = function decryptJWE(jwe, decrypter) {\n  try {\n    var _exit;\n\n    function _temp5(_result) {\n      if (_exit) ;\n      if (cleartext === null) throw new Error('failure: Failed to decrypt');\n      return cleartext;\n    }\n\n    validateJWE(jwe);\n    var protHeader = JSON.parse(decodeBase64url(jwe.protected));\n    if (protHeader.enc !== decrypter.enc) throw new Error(\"not_supported: Decrypter does not supported: '\".concat(protHeader.enc, \"'\"));\n    var sealed = toSealed(jwe.ciphertext, jwe.tag);\n    var aad = new Uint8Array(Buffer.from(jwe.aad ? \"\".concat(jwe.protected, \".\").concat(jwe.aad) : jwe.protected));\n    var cleartext = null;\n\n    var _temp4 = function () {\n      if (protHeader.alg === 'dir' && decrypter.alg === 'dir') {\n        return Promise.resolve(decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad)).then(function (_decrypter$decrypt) {\n          cleartext = _decrypter$decrypt;\n        });\n      } else return function () {\n        if (!jwe.recipients || jwe.recipients.length === 0) {\n          throw new Error('bad_jwe: missing recipients');\n        } else {\n          var i = 0;\n          return _for(function () {\n            return !cleartext && i < jwe.recipients.length;\n          }, function () {\n            return i++;\n          }, function () {\n            var recipient = jwe.recipients[i];\n            Object.assign(recipient.header, protHeader);\n\n            var _temp3 = function () {\n              if (recipient.header.alg === decrypter.alg) {\n                return Promise.resolve(decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad, recipient)).then(function (_decrypter$decrypt2) {\n                  cleartext = _decrypter$decrypt2;\n                });\n              }\n            }();\n\n            if (_temp3 && _temp3.then) return _temp3.then(function () {});\n          });\n        }\n      }();\n    }();\n\n    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp5) : _temp5(_temp4));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar _iteratorSymbol = typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\")) : \"@@iterator\";\n\nfunction _settle(pact, state, value) {\n  if (!pact.s) {\n    if (value instanceof _Pact) {\n      if (value.s) {\n        if (state & 1) {\n          state = value.s;\n        }\n\n        value = value.v;\n      } else {\n        value.o = _settle.bind(null, pact, state);\n        return;\n      }\n    }\n\n    if (value && value.then) {\n      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n      return;\n    }\n\n    pact.s = state;\n    pact.v = value;\n    var observer = pact.o;\n\n    if (observer) {\n      observer(pact);\n    }\n  }\n}\n\nvar _Pact = /*#__PURE__*/function () {\n  function _Pact() {}\n\n  _Pact.prototype.then = function (onFulfilled, onRejected) {\n    var result = new _Pact();\n    var state = this.s;\n\n    if (state) {\n      var callback = state & 1 ? onFulfilled : onRejected;\n\n      if (callback) {\n        try {\n          _settle(result, 1, callback(this.v));\n        } catch (e) {\n          _settle(result, 2, e);\n        }\n\n        return result;\n      } else {\n        return this;\n      }\n    }\n\n    this.o = function (_this) {\n      try {\n        var value = _this.v;\n\n        if (_this.s & 1) {\n          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n        } else if (onRejected) {\n          _settle(result, 1, onRejected(value));\n        } else {\n          _settle(result, 2, value);\n        }\n      } catch (e) {\n        _settle(result, 2, e);\n      }\n    };\n\n    return result;\n  };\n\n  return _Pact;\n}();\n\nfunction _isSettledPact(thenable) {\n  return thenable instanceof _Pact && thenable.s & 1;\n}\n\nfunction _forTo(array, body, check) {\n  var i = -1,\n      pact,\n      reject;\n\n  function _cycle(result) {\n    try {\n      while (++i < array.length && (!check || !check())) {\n        result = body(i);\n\n        if (result && result.then) {\n          if (_isSettledPact(result)) {\n            result = result.v;\n          } else {\n            result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n            return;\n          }\n        }\n      }\n\n      if (pact) {\n        _settle(pact, 1, result);\n      } else {\n        pact = result;\n      }\n    } catch (e) {\n      _settle(pact || (pact = new _Pact()), 2, e);\n    }\n  }\n\n  _cycle();\n\n  return pact;\n}\n\nfunction _forOf(target, body, check) {\n  if (typeof target[_iteratorSymbol] === \"function\") {\n    var iterator = target[_iteratorSymbol](),\n        step,\n        pact,\n        reject;\n\n    function _cycle(result) {\n      try {\n        while (!(step = iterator.next()).done && (!check || !check())) {\n          result = body(step.value);\n\n          if (result && result.then) {\n            if (_isSettledPact(result)) {\n              result = result.v;\n            } else {\n              result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n              return;\n            }\n          }\n        }\n\n        if (pact) {\n          _settle(pact, 1, result);\n        } else {\n          pact = result;\n        }\n      } catch (e) {\n        _settle(pact || (pact = new _Pact()), 2, e);\n      }\n    }\n\n    _cycle();\n\n    if (iterator.return) {\n      var _fixup = function _fixup(value) {\n        try {\n          if (!step.done) {\n            iterator.return();\n          }\n        } catch (e) {}\n\n        return value;\n      };\n\n      if (pact && pact.then) {\n        return pact.then(_fixup, function (e) {\n          throw _fixup(e);\n        });\n      }\n\n      _fixup();\n    }\n\n    return pact;\n  } // No support for Symbol.iterator\n  // No support for Symbol.iterator\n\n\n  if (!(\"length\" in target)) {\n    throw new TypeError(\"Object is not iterable\");\n  } // Handle live collections properly\n  // Handle live collections properly\n\n\n  var values = [];\n\n  for (var i = 0; i < target.length; i++) {\n    values.push(target[i]);\n  }\n\n  return _forTo(values, function (i) {\n    return body(values[i]);\n  }, check);\n}\n\nfunction validateJWE(jwe) {\n  if (!(jwe.protected && jwe.iv && jwe.ciphertext && jwe.tag)) {\n    throw new Error('bad_jwe: missing properties');\n  }\n\n  if (jwe.recipients) {\n    jwe.recipients.map(function (rec) {\n      if (!(rec.header && rec.encrypted_key)) {\n        throw new Error('bad_jwe: malformed recipients');\n      }\n    });\n  }\n}\n\nfunction encodeJWE(_ref9, aad) {\n  var ciphertext = _ref9.ciphertext,\n      tag = _ref9.tag,\n      iv = _ref9.iv,\n      protectedHeader = _ref9.protectedHeader,\n      recipient = _ref9.recipient;\n  var jwe = {\n    protected: protectedHeader,\n    iv: bytesToBase64url(iv),\n    ciphertext: bytesToBase64url(ciphertext),\n    tag: bytesToBase64url(tag)\n  };\n  if (aad) jwe.aad = bytesToBase64url(aad);\n  if (recipient) jwe.recipients = [recipient];\n  return jwe;\n}\n\nvar createJWE = function createJWE(cleartext, encrypters) {\n  var protectedHeader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var aad = arguments.length > 3 ? arguments[3] : undefined;\n\n  try {\n    if (encrypters[0].alg === 'dir') {\n      if (encrypters.length > 1) throw new Error('not_supported: Can only do \"dir\" encryption to one key.');\n      return Promise.resolve(encrypters[0].encrypt(cleartext, protectedHeader, aad)).then(function (encryptionResult) {\n        return encodeJWE(encryptionResult, aad);\n      });\n    } else {\n      var tmpEnc = encrypters[0].enc;\n\n      if (!encrypters.reduce(function (acc, encrypter) {\n        return acc && encrypter.enc === tmpEnc;\n      }, true)) {\n        throw new Error('invalid_argument: Incompatible encrypters passed');\n      }\n\n      var cek;\n      var jwe;\n\n      var _temp2 = _forOf(encrypters, function (encrypter) {\n        var _temp = function () {\n          if (!cek) {\n            return Promise.resolve(encrypter.encrypt(cleartext, protectedHeader, aad)).then(function (encryptionResult) {\n              cek = encryptionResult.cek;\n              jwe = encodeJWE(encryptionResult, aad);\n            });\n          } else {\n            return Promise.resolve(encrypter.encryptCek == null ? void 0 : encrypter.encryptCek(cek)).then(function (recipient) {\n              if (recipient) {\n                var _jwe, _jwe$recipients;\n\n                (_jwe = jwe) == null ? void 0 : (_jwe$recipients = _jwe.recipients) == null ? void 0 : _jwe$recipients.push(recipient);\n              }\n            });\n          }\n        }();\n\n        if (_temp && _temp.then) return _temp.then(function () {});\n      });\n\n      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {\n        return jwe;\n      }) : jwe);\n    }\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n/**\r\n * Wraps an X25519 secret key into an ECDH method that can be used to compute a shared secret with a public key.\r\n * @param mySecretKey A `Uint8Array` of length 32 representing the bytes of my secret key\r\n * @returns an `ECDH` method with the signature `(theirPublicKey: Uint8Array) => Promise<Uint8Array>`\r\n *\r\n * @throws 'invalid_argument:...' if the secret key size is wrong\r\n */\n\n\nfunction createX25519ECDH(mySecretKey) {\n  if (mySecretKey.length !== 32) {\n    throw new Error('invalid_argument: incorrect secret key length for X25519');\n  }\n\n  return function (theirPublicKey) {\n    try {\n      if (theirPublicKey.length !== 32) {\n        throw new Error('invalid_argument: incorrect publicKey key length for X25519');\n      }\n\n      return Promise.resolve(sharedKey(mySecretKey, theirPublicKey));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n/**\r\n * Recommended encrypter for authenticated encryption (i.e. sender authentication and requires\r\n * sender private key to encrypt the data).\r\n * Uses {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU v3 } and\r\n * {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW v2 }.\r\n *\r\n * @param recipientPublicKey the byte array representing the recipient public key\r\n * @param senderSecret either a Uint8Array representing the sender secret key or\r\n *   an ECDH function that wraps the key and can promise a shared secret given a public key\r\n * @param options {@link AuthEncryptParams} used to specify extra header parameters\r\n *\r\n * @returns an {@link Encrypter} instance usable with {@link createJWE}\r\n *\r\n * NOTE: ECDH-1PU and XC20PKW are proposed drafts in IETF and not a standard yet and\r\n * are subject to change as new revisions or until the official CFRG specification are released.\r\n *\r\n * @beta\r\n */\n\n\nvar resolveX25519Encrypters = function resolveX25519Encrypters(dids, resolver) {\n  try {\n    var encryptersForDID = function encryptersForDID(did) {\n      try {\n        return Promise.resolve(resolver.resolve(did)).then(function (_ref10) {\n          var didResolutionMetadata = _ref10.didResolutionMetadata,\n              didDocument = _ref10.didDocument;\n\n          var _didDocument$keyAgree;\n\n          if (didResolutionMetadata != null && didResolutionMetadata.error || didDocument == null) {\n            throw new Error(\"resolver_error: Could not resolve \".concat(did, \": \").concat(didResolutionMetadata.error, \", \").concat(didResolutionMetadata.message));\n          }\n\n          if (!didDocument.keyAgreement) throw new Error(\"no_suitable_keys: Could not find x25519 key for \".concat(did));\n          var agreementKeys = (_didDocument$keyAgree = didDocument.keyAgreement) == null ? void 0 : _didDocument$keyAgree.map(function (key) {\n            if (typeof key === 'string') {\n              return [].concat(_toConsumableArray(didDocument.publicKey || []), _toConsumableArray(didDocument.verificationMethod || [])).find(function (pk) {\n                return pk.id === key;\n              });\n            }\n\n            return key;\n          }).filter(function (key) {\n            return typeof key !== 'undefined';\n          });\n          var pks = agreementKeys.filter(function (key) {\n            // TODO: should be able to use non base58 keys too\n            return key.type === 'X25519KeyAgreementKey2019' && Boolean(key.publicKeyBase58);\n          });\n          if (!pks.length) throw new Error(\"no_suitable_keys: Could not find x25519 key for \".concat(did));\n          return pks.map(function (pk) {\n            return x25519Encrypter(base58ToBytes(pk.publicKeyBase58), pk.id);\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    var encrypterPromises = dids.map(function (did) {\n      return encryptersForDID(did);\n    });\n    return Promise.resolve(Promise.all(encrypterPromises)).then(function (encrypterArrays) {\n      var _ref11;\n\n      var flattenedArray = (_ref11 = []).concat.apply(_ref11, _toConsumableArray(encrypterArrays));\n\n      return flattenedArray;\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nfunction createAuthEncrypter(recipientPublicKey, senderSecret) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2(recipientPublicKey, senderSecret, options);\n}\n/**\r\n * Recommended encrypter for anonymous encryption (i.e. no sender authentication).\r\n * Uses {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | ECDH-ES+XC20PKW v2}.\r\n *\r\n * @param publicKey the byte array representing the recipient public key\r\n * @param options {@link AnonEncryptParams} used to specify the recipient key ID (`kid`)\r\n *\r\n * @returns an {@link Encrypter} instance usable with {@link createJWE}\r\n *\r\n * NOTE: ECDH-ES+XC20PKW is a proposed draft in IETF and not a standard yet and\r\n * is subject to change as new revisions or until the official CFRG specification is released.\r\n *\r\n * @beta\r\n */\n\n\nfunction createAnonEncrypter(publicKey) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return x25519Encrypter(publicKey, options == null ? void 0 : options.kid);\n}\n/**\r\n * Recommended decrypter for authenticated encryption (i.e. sender authentication and requires\r\n * sender public key to decrypt the data).\r\n * Uses {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU v3 } and\r\n * {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW v2 }.\r\n *\r\n * @param recipientSecret either a Uint8Array representing the recipient secret key or\r\n *   an ECDH function that wraps the key and can promise a shared secret given a public key\r\n * @param senderPublicKey the byte array representing the sender public key\r\n *\r\n * @returns a {@link Decrypter} instance usable with {@link decryptJWE}\r\n *\r\n * NOTE: ECDH-1PU and XC20PKW are proposed drafts in IETF and not a standard yet and\r\n * are subject to change as new revisions or until the official CFRG specification are released.\r\n *\r\n * @beta\r\n */\n\n\nfunction createAuthDecrypter(recipientSecret, senderPublicKey) {\n  return xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2(recipientSecret, senderPublicKey);\n}\n/**\r\n * Recommended decrypter for anonymous encryption (i.e. no sender authentication).\r\n * Uses {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | ECDH-ES+XC20PKW v2 }.\r\n *\r\n * @param recipientSecret either a Uint8Array representing the recipient secret key or\r\n *   an ECDH function that wraps the key and can promise a shared secret given a public key\r\n *\r\n * @returns a {@link Decrypter} instance usable with {@link decryptJWE}\r\n *\r\n * NOTE: ECDH-ES+XC20PKW is a proposed draft in IETF and not a standard yet and\r\n * is subject to change as new revisions or until the official CFRG specification is released.\r\n *\r\n * @beta\r\n */\n\n\nfunction createAnonDecrypter(recipientSecret) {\n  return x25519Decrypter(recipientSecret);\n}\n\nfunction xc20pEncrypter(key) {\n  var cipher = new XChaCha20Poly1305(key);\n  return function (cleartext, aad) {\n    var iv = randomBytes(cipher.nonceLength);\n    var sealed = cipher.seal(iv, cleartext, aad);\n    return {\n      ciphertext: sealed.subarray(0, sealed.length - cipher.tagLength),\n      tag: sealed.subarray(sealed.length - cipher.tagLength),\n      iv: iv\n    };\n  };\n}\n\nfunction xc20pDirEncrypter(key) {\n  var encrypt = function encrypt(cleartext) {\n    var protectedHeader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var aad = arguments.length > 2 ? arguments[2] : undefined;\n\n    try {\n      var protHeader = encodeBase64url(JSON.stringify(Object.assign({\n        alg: alg\n      }, protectedHeader, {\n        enc: enc\n      })));\n      var encodedAad = new Uint8Array(Buffer.from(aad ? \"\".concat(protHeader, \".\").concat(bytesToBase64url(aad)) : protHeader));\n      return Promise.resolve(_objectSpread(_objectSpread({}, xc20pEncrypt(cleartext, encodedAad)), {}, {\n        protectedHeader: protHeader\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  var xc20pEncrypt = xc20pEncrypter(key);\n  var enc = 'XC20P';\n  var alg = 'dir';\n  return {\n    alg: alg,\n    enc: enc,\n    encrypt: encrypt\n  };\n}\n\nfunction xc20pDirDecrypter(key) {\n  var decrypt = function decrypt(sealed, iv, aad) {\n    try {\n      return Promise.resolve(cipher.open(iv, sealed, aad));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  var cipher = new XChaCha20Poly1305(key);\n  return {\n    alg: 'dir',\n    enc: 'XC20P',\n    decrypt: decrypt\n  };\n}\n\nfunction x25519Encrypter(publicKey, kid) {\n  var encrypt = function encrypt(cleartext) {\n    var protectedHeader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var aad = arguments.length > 2 ? arguments[2] : undefined;\n\n    try {\n      // we won't want alg to be set to dir from xc20pDirEncrypter\n      Object.assign(protectedHeader, {\n        alg: undefined\n      }); // Content Encryption Key\n\n      var cek = randomBytes(32);\n      return Promise.resolve(xc20pDirEncrypter(cek).encrypt(cleartext, protectedHeader, aad)).then(function (_xc20pDirEncrypter$en) {\n        return Promise.resolve(encryptCek(cek)).then(function (_encryptCek) {\n          return _objectSpread(_objectSpread({}, _xc20pDirEncrypter$en), {}, {\n            recipient: _encryptCek,\n            cek: cek\n          });\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  var encryptCek = function encryptCek(cek) {\n    try {\n      var epk = generateKeyPair();\n      var sharedSecret = sharedKey(epk.secretKey, publicKey); // Key Encryption Key\n\n      var kek = concatKDF(sharedSecret, keyLen, alg);\n      var res = xc20pEncrypter(kek)(cek);\n      var recipient = {\n        encrypted_key: bytesToBase64url(res.ciphertext),\n        header: {\n          alg: alg,\n          iv: bytesToBase64url(res.iv),\n          tag: bytesToBase64url(res.tag),\n          epk: {\n            kty: 'OKP',\n            crv: crv,\n            x: bytesToBase64url(epk.publicKey)\n          }\n        }\n      };\n      if (kid) recipient.header.kid = kid;\n      return Promise.resolve(recipient);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  var alg = 'ECDH-ES+XC20PKW';\n  var keyLen = 256;\n  var crv = 'X25519';\n  return {\n    alg: alg,\n    enc: 'XC20P',\n    encrypt: encrypt,\n    encryptCek: encryptCek\n  };\n}\n/**\r\n * Implements ECDH-1PU+XC20PKW with XChaCha20Poly1305 based on the following specs:\r\n *   - {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW}\r\n *   - {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU}\r\n */\n\n\nfunction xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2(recipientPublicKey, senderSecret) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var encrypt = function encrypt(cleartext) {\n    var protectedHeader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var aad = arguments.length > 2 ? arguments[2] : undefined;\n\n    try {\n      // we won't want alg to be set to dir from xc20pDirEncrypter\n      Object.assign(protectedHeader, {\n        alg: undefined\n      }); // Content Encryption Key\n\n      var cek = randomBytes(32);\n      return Promise.resolve(xc20pDirEncrypter(cek).encrypt(cleartext, protectedHeader, aad)).then(function (_xc20pDirEncrypter$en2) {\n        return Promise.resolve(encryptCek(cek)).then(function (_encryptCek2) {\n          return _objectSpread(_objectSpread({}, _xc20pDirEncrypter$en2), {}, {\n            recipient: _encryptCek2,\n            cek: cek\n          });\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  var encryptCek = function encryptCek(cek) {\n    try {\n      function _temp2() {\n        var sharedSecret = new Uint8Array(zE.length + zS.length);\n        sharedSecret.set(zE);\n        sharedSecret.set(zS, zE.length); // Key Encryption Key\n\n        var kek = concatKDF(sharedSecret, keyLen, alg, partyUInfo, partyVInfo);\n        var res = xc20pEncrypter(kek)(cek);\n        var recipient = {\n          encrypted_key: bytesToBase64url(res.ciphertext),\n          header: {\n            alg: alg,\n            iv: bytesToBase64url(res.iv),\n            tag: bytesToBase64url(res.tag),\n            epk: {\n              kty: 'OKP',\n              crv: crv,\n              x: bytesToBase64url(epk.publicKey)\n            }\n          }\n        };\n        if (options.kid) recipient.header.kid = options.kid;\n        if (options.apu) recipient.header.apu = options.apu;\n        if (options.apv) recipient.header.apv = options.apv;\n        return recipient;\n      }\n\n      var epk = generateKeyPair();\n      var zE = sharedKey(epk.secretKey, recipientPublicKey); // ECDH-1PU requires additional shared secret between\n      // static key of sender and static key of recipient\n\n      var zS;\n\n      var _temp = function () {\n        if (senderSecret instanceof Uint8Array) {\n          zS = sharedKey(senderSecret, recipientPublicKey);\n        } else {\n          return Promise.resolve(senderSecret(recipientPublicKey)).then(function (_senderSecret) {\n            zS = _senderSecret;\n          });\n        }\n      }();\n\n      return Promise.resolve(_temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  var alg = 'ECDH-1PU+XC20PKW';\n  var keyLen = 256;\n  var crv = 'X25519';\n  var partyUInfo;\n  var partyVInfo;\n  if (options.apu !== undefined) partyUInfo = base64ToBytes(options.apu);\n  if (options.apv !== undefined) partyVInfo = base64ToBytes(options.apv);\n  return {\n    alg: alg,\n    enc: 'XC20P',\n    encrypt: encrypt,\n    encryptCek: encryptCek\n  };\n}\n\nfunction validateHeader(header) {\n  if (!(header && header.epk && header.iv && header.tag)) {\n    throw new Error('bad_jwe: malformed header');\n  }\n}\n\nfunction x25519Decrypter(receiverSecret) {\n  var decrypt = function decrypt(sealed, iv, aad, recipient) {\n    try {\n      var _recipient, _recipient$header$epk;\n\n      function _temp4() {\n        // Key Encryption Key\n        var kek = concatKDF(sharedSecret, keyLen, alg); // Content Encryption Key\n\n        var sealedCek = toSealed(recipient.encrypted_key, recipient.header.tag);\n        return Promise.resolve(xc20pDirDecrypter(kek).decrypt(sealedCek, base64ToBytes(recipient.header.iv))).then(function (cek) {\n          return cek === null ? null : xc20pDirDecrypter(cek).decrypt(sealed, iv, aad);\n        });\n      }\n\n      validateHeader((_recipient = recipient) == null ? void 0 : _recipient.header);\n      recipient = recipient;\n      if (((_recipient$header$epk = recipient.header.epk) == null ? void 0 : _recipient$header$epk.crv) !== crv || typeof recipient.header.epk.x == 'undefined') return Promise.resolve(null);\n      var publicKey = base64ToBytes(recipient.header.epk.x);\n      var sharedSecret;\n\n      var _temp3 = function () {\n        if (receiverSecret instanceof Uint8Array) {\n          sharedSecret = sharedKey(receiverSecret, publicKey);\n        } else {\n          return Promise.resolve(receiverSecret(publicKey)).then(function (_receiverSecret) {\n            sharedSecret = _receiverSecret;\n          });\n        }\n      }();\n\n      return Promise.resolve(_temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  var alg = 'ECDH-ES+XC20PKW';\n  var keyLen = 256;\n  var crv = 'X25519';\n  return {\n    alg: alg,\n    enc: 'XC20P',\n    decrypt: decrypt\n  };\n}\n/**\r\n * Implements ECDH-1PU+XC20PKW with XChaCha20Poly1305 based on the following specs:\r\n *   - {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW}\r\n *   - {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU}\r\n */\n\n\nfunction xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2(recipientSecret, senderPublicKey) {\n  var decrypt = function decrypt(sealed, iv, aad, recipient) {\n    try {\n      var _recipient$header$epk2;\n\n      function _temp6() {\n        var sharedSecret = new Uint8Array(zE.length + zS.length);\n        sharedSecret.set(zE);\n        sharedSecret.set(zS, zE.length); // Key Encryption Key\n\n        var producerInfo;\n        var consumerInfo;\n        if (recipient.header.apu) producerInfo = base64ToBytes(recipient.header.apu);\n        if (recipient.header.apv) consumerInfo = base64ToBytes(recipient.header.apv);\n        var kek = concatKDF(sharedSecret, keyLen, alg, producerInfo, consumerInfo); // Content Encryption Key\n\n        var sealedCek = toSealed(recipient.encrypted_key, recipient.header.tag);\n        return Promise.resolve(xc20pDirDecrypter(kek).decrypt(sealedCek, base64ToBytes(recipient.header.iv))).then(function (cek) {\n          return cek === null ? null : xc20pDirDecrypter(cek).decrypt(sealed, iv, aad);\n        });\n      }\n\n      recipient = recipient;\n      validateHeader(recipient.header);\n      if (((_recipient$header$epk2 = recipient.header.epk) == null ? void 0 : _recipient$header$epk2.crv) !== crv || typeof recipient.header.epk.x == 'undefined') return Promise.resolve(null); // ECDH-1PU requires additional shared secret between\n      // static key of sender and static key of recipient\n\n      var publicKey = base64ToBytes(recipient.header.epk.x);\n      var zE;\n      var zS;\n\n      var _temp5 = function () {\n        if (recipientSecret instanceof Uint8Array) {\n          zE = sharedKey(recipientSecret, publicKey);\n          zS = sharedKey(recipientSecret, senderPublicKey);\n        } else {\n          return Promise.resolve(recipientSecret(publicKey)).then(function (_recipientSecret) {\n            zE = _recipientSecret;\n            return Promise.resolve(recipientSecret(senderPublicKey)).then(function (_recipientSecret2) {\n              zS = _recipientSecret2;\n            });\n          });\n        }\n      }();\n\n      return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(_temp6) : _temp6(_temp5));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  var alg = 'ECDH-1PU+XC20PKW';\n  var keyLen = 256;\n  var crv = 'X25519';\n  return {\n    alg: alg,\n    enc: 'XC20P',\n    decrypt: decrypt\n  };\n}\n\nexport { ES256KSigner, EdDSASigner, EllipticSigner, NaclSigner, SimpleSigner, createAnonDecrypter, createAnonEncrypter, createAuthDecrypter, createAuthEncrypter, createJWE, createJWS, createJWT, createX25519ECDH, decodeJWT, decryptJWE, resolveX25519Encrypters, toEthereumAddress, verifyJWS, verifyJWT, x25519Decrypter, x25519Encrypter, xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2, xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2, xc20pDirDecrypter, xc20pDirEncrypter };","map":{"version":3,"sources":["../src/util.ts","../src/Digest.ts","../src/signers/ES256KSigner.ts","../src/signers/SimpleSigner.ts","../src/signers/EllipticSigner.ts","../src/signers/EdDSASigner.ts","../src/signers/NaclSigner.ts","../src/SignerAlgorithm.ts","../src/VerifierAlgorithm.ts","../src/JWT.ts","../src/JWE.ts","../src/ECDH.ts","../src/xc20pEncryption.ts"],"names":["bytesToBase64url","b","u8a","base64ToBytes","s","inputBase64Url","base58ToBytes","hexToBytes","input","encodeBase64url","decodeBase64url","bytesToHex","stringToBytes","toJose","recoveryParam","recoverable","jose","fromJose","signature","signatureBytes","r","toSealed","ciphertext","tag","hexMatcher","base58Matcher","base64Matcher","parseKey","TypeError","leftpad","data","size","sha256","payload","hash","keccak","keccak_256","toEthereumAddress","hexPublicKey","hashInput","array","encoded","value","lengthAndInput","writeUint32BE","concatKDF","secret","keyLen","alg","producerInfo","consumerInfo","roundNumber","secp256k1","ES256KSigner","privateKey","privateKeyBytes","keyPair","signer","EdDSASigner","secretKey","dataBytes","sig","sign","ES256KSignerAlg","instanceOfEcdsaSignature","Ed25519SignerAlg","algorithms","ES256K","Ed25519","EdDSA","impl","toSignatureObject","rawSig","sigObj","pk","x","y","verifyES256K","authenticators","fullPublicKeys","blockchainAccountId","ethAddressKeys","pubBytes","extractPublicKeyBytes","verifyRecoverableES256K","signatures","so","checkSignatureAgainstSigner","recoveredKey","recoveredPublicKeyHex","recoveredCompressedPublicKeyHex","recoveredAddress","keyHex","key","verifyEd25519","clear","verify","VerifierAlgorithm","SUPPORTED_PUBLIC_KEY_TYPES","defaultAlg","DID_JSON","shouldCanonicalize","canonicalizeData","JSON","NBF_SKEW","parts","jws","header","decodeJWT","jwt","decodeJWS","decodedJwt","createJWS","options","encodedPayload","encodeSection","signingInput","jwtSigner","SignerAlg","createJWT","canonicalize","timestamps","iat","Math","Date","exp","undefined","fullPayload","iss","issuer","Array","pubKeys","verifyJWS","jwsDecoded","verifyJWSDecoded","verifyJWT","resolver","auth","audience","callbackUrl","skewTime","proofPurpose","Object","resolveAuthenticator","now","nowSkewed","audArray","matchedAudience","item","didResolutionResult","types","result","accept","didResult","didDocument","didDocumentMetadata","didResolutionMetadata","contentType","message","error","getPublicKeyById","filtered","verificationMethods","id","pubid","publicKeysToCheck","verificationMethod","type","supported","jwe","rec","recipient","protected","iv","createJWE","protectedHeader","encrypters","e","encodeJWE","tmpEnc","acc","encrypter","cek","encryptionResult","decryptJWE","validateJWE","protHeader","decrypter","sealed","aad","Buffer","cleartext","i","length","createX25519ECDH","mySecretKey","theirPublicKey","sharedKey","createAuthEncrypter","recipientPublicKey","senderSecret","xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2","createAnonEncrypter","publicKey","x25519Encrypter","createAuthDecrypter","recipientSecret","senderPublicKey","xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2","createAnonDecrypter","x25519Decrypter","cipher","randomBytes","xc20pDirEncrypter","xc20pEncrypt","xc20pEncrypter","enc","encrypt","encodedAad","xc20pDirDecrypter","decrypt","kid","crv","encryptCek","epk","generateKeyPair","sharedSecret","kek","res","encrypted_key","kty","partyUInfo","partyVInfo","zE","Uint8Array","zS","resolveX25519Encrypters","encryptersForDID","did","agreementKeys","pks","Boolean","encrypterPromises","dids","encrypterArrays","Promise","flattenedArray","receiverSecret","validateHeader","sealedCek"],"mappings":"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","sourcesContent":["import * as u8a from 'uint8arrays'\n\n/**\n * @deprecated Signers will be expected to return base64url `string` signatures.\n */\nexport interface EcdsaSignature {\n  r: string\n  s: string\n  recoveryParam?: number | null\n}\n\nexport function bytesToBase64url(b: Uint8Array): string {\n  return u8a.toString(b, 'base64url')\n}\n\nexport function base64ToBytes(s: string): Uint8Array {\n  const inputBase64Url = s.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '')\n  return u8a.fromString(inputBase64Url, 'base64url')\n}\n\nexport function bytesToBase64(b: Uint8Array): string {\n  return u8a.toString(b, 'base64pad')\n}\n\nexport function base58ToBytes(s: string): Uint8Array {\n  return u8a.fromString(s, 'base58btc')\n}\n\nexport function bytesToBase58(b: Uint8Array): string {\n  return u8a.toString(b, 'base58btc')\n}\n\nexport function hexToBytes(s: string): Uint8Array {\n  const input = s.startsWith('0x') ? s.substring(2) : s\n  return u8a.fromString(input.toLowerCase(), 'base16')\n}\n\nexport function encodeBase64url(s: string): string {\n  return bytesToBase64url(u8a.fromString(s))\n}\n\nexport function decodeBase64url(s: string): string {\n  return u8a.toString(base64ToBytes(s))\n}\n\nexport function bytesToHex(b: Uint8Array): string {\n  return u8a.toString(b, 'base16')\n}\n\nexport function stringToBytes(s: string): Uint8Array {\n  return u8a.fromString(s)\n}\n\nexport function toJose({ r, s, recoveryParam }: EcdsaSignature, recoverable?: boolean): string {\n  const jose = new Uint8Array(recoverable ? 65 : 64)\n  jose.set(u8a.fromString(r, 'base16'), 0)\n  jose.set(u8a.fromString(s, 'base16'), 32)\n  if (recoverable) {\n    if (typeof recoveryParam === 'undefined') {\n      throw new Error('Signer did not return a recoveryParam')\n    }\n    jose[64] = <number>recoveryParam\n  }\n  return bytesToBase64url(jose)\n}\n\nexport function fromJose(signature: string): { r: string; s: string; recoveryParam?: number } {\n  const signatureBytes: Uint8Array = base64ToBytes(signature)\n  if (signatureBytes.length < 64 || signatureBytes.length > 65) {\n    throw new TypeError(`Wrong size for signature. Expected 64 or 65 bytes, but got ${signatureBytes.length}`)\n  }\n  const r = bytesToHex(signatureBytes.slice(0, 32))\n  const s = bytesToHex(signatureBytes.slice(32, 64))\n  const recoveryParam = signatureBytes.length === 65 ? signatureBytes[64] : undefined\n  return { r, s, recoveryParam }\n}\n\nexport function toSealed(ciphertext: string, tag: string): Uint8Array {\n  return u8a.concat([base64ToBytes(ciphertext), base64ToBytes(tag)])\n}\n\nconst hexMatcher = /^(0x)?([a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/\nconst base58Matcher = /^([1-9A-HJ-NP-Za-km-z]{44}|[1-9A-HJ-NP-Za-km-z]{88})$/\nconst base64Matcher = /^([0-9a-zA-Z=\\-_+/]{43}|[0-9a-zA-Z=\\-_+/]{86})(={0,2})$/\n\n/**\n * Parses a private key and returns the Uint8Array representation.\n * This method uses an heuristic to determine the key encoding to then be able to parse it into 32 or 64 bytes.\n *\n * @param input a 32 or 64 byte key presented either as a Uint8Array or as a hex, base64, or base58btc encoded string\n *\n * @throws TypeError('Invalid private key format') if the key doesn't match any of the accepted formats or length\n */\nexport function parseKey(input: string | Uint8Array): Uint8Array {\n  if (typeof input === 'string') {\n    if (hexMatcher.test(input)) {\n      return hexToBytes(input)\n    } else if (base58Matcher.test(input)) {\n      return base58ToBytes(input)\n    } else if (base64Matcher.test(input)) {\n      return base64ToBytes(input)\n    } else {\n      throw TypeError('bad_key: Invalid private key format')\n    }\n  } else if (input instanceof Uint8Array) {\n    return input\n  } else {\n    throw TypeError('bad_key: Invalid private key format')\n  }\n}\n\nexport function leftpad(data: string, size = 64): string {\n  if (data.length === size) return data\n  return '0'.repeat(size - data.length) + data\n}\n","import { hash } from '@stablelib/sha256'\nimport * as u8a from 'uint8arrays'\nimport { keccak_256 } from 'js-sha3' // eslint-disable-line\n\nexport function sha256(payload: string | Uint8Array): Uint8Array {\n  const data = typeof payload === 'string' ? u8a.fromString(payload) : payload\n  return hash(data)\n}\n\nexport function keccak(data: Uint8Array): Uint8Array {\n  return new Uint8Array(keccak_256.arrayBuffer(data))\n}\n\nexport function toEthereumAddress(hexPublicKey: string): string {\n  const hashInput = u8a.fromString(hexPublicKey.slice(2), 'base16')\n  return `0x${u8a.toString(keccak(hashInput).slice(-20), 'base16')}`\n}\n\nfunction writeUint32BE(value: number, array = new Uint8Array(4)): Uint8Array {\n  const encoded = u8a.fromString(value.toString(), 'base10')\n  array.set(encoded, 4 - encoded.length)\n  return array\n}\n\nconst lengthAndInput = (input: Uint8Array): Uint8Array => u8a.concat([writeUint32BE(input.length), input])\n\n// This implementation of concatKDF was inspired by these two implementations:\n// https://github.com/digitalbazaar/minimal-cipher/blob/master/algorithms/ecdhkdf.js\n// https://github.com/panva/jose/blob/master/lib/jwa/ecdh/derive.js\nexport function concatKDF(\n  secret: Uint8Array,\n  keyLen: number,\n  alg: string,\n  producerInfo?: Uint8Array,\n  consumerInfo?: Uint8Array\n): Uint8Array {\n  if (keyLen !== 256) throw new Error(`Unsupported key length: ${keyLen}`)\n  const value = u8a.concat([\n    lengthAndInput(u8a.fromString(alg)),\n    lengthAndInput(typeof producerInfo === 'undefined' ? new Uint8Array(0) : producerInfo), // apu\n    lengthAndInput(typeof consumerInfo === 'undefined' ? new Uint8Array(0) : consumerInfo), // apv\n    writeUint32BE(keyLen),\n  ])\n\n  // since our key lenght is 256 we only have to do one round\n  const roundNumber = 1\n  return hash(u8a.concat([writeUint32BE(roundNumber), secret, value]))\n}\n","import { parseKey, leftpad } from '../util'\nimport { toJose } from '../util'\nimport { Signer } from '../JWT'\nimport { sha256 } from '../Digest'\n\nimport { ec as EC, ec } from 'elliptic'\nconst secp256k1: EC = new EC('secp256k1')\n\n/**\n *  Creates a configured signer function for signing data using the ES256K (secp256k1 + sha256) algorithm.\n *\n *  The signing function itself takes the data as a `Uint8Array` or `string` and returns a `base64Url`-encoded signature\n *\n *  @example\n *  ```typescript\n *  const sign: Signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  const signature: string = await sign(data)\n *  ```\n *\n *  @param    {String}    privateKey   a private key as `Uint8Array` or encoded as `base64`, `base58`, or `hex` string\n *  @param    {Boolean}   recoverable  an optional flag to add the recovery param to the generated signatures\n *  @return   {Function}               a configured signer function `(data: string | Uint8Array): Promise<string>`\n */\nexport function ES256KSigner(privateKey: string | Uint8Array, recoverable = false): Signer {\n  const privateKeyBytes: Uint8Array = parseKey(privateKey)\n  if (privateKeyBytes.length !== 32) {\n    throw new Error(`bad_key: Invalid private key format. Expecting 32 bytes, but got ${privateKeyBytes.length}`)\n  }\n  const keyPair: ec.KeyPair = secp256k1.keyFromPrivate(privateKeyBytes)\n\n  return async (data: string | Uint8Array): Promise<string> => {\n    const { r, s, recoveryParam }: EC.Signature = keyPair.sign(sha256(data))\n    return toJose(\n      {\n        r: leftpad(r.toString('hex')),\n        s: leftpad(s.toString('hex')),\n        recoveryParam,\n      },\n      recoverable\n    )\n  }\n}\n","import { fromJose } from '../util'\nimport { Signer } from '../JWT'\nimport { ES256KSigner } from './ES256KSigner'\n\n/**\n * @deprecated Please use ES256KSigner\n *  The SimpleSigner returns a configured function for signing data.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                     a configured signer function\n */\nfunction SimpleSigner(hexPrivateKey: string): Signer {\n  const signer = ES256KSigner(hexPrivateKey, true)\n  return async (data) => {\n    const signature = (await signer(data)) as string\n    return fromJose(signature)\n  }\n}\n\nexport default SimpleSigner\n","import { Signer } from '../JWT'\nimport { ES256KSigner } from './ES256KSigner'\n\n/**\n * @deprecated Please use ES256KSigner\n *  The EllipticSigner returns a configured function for signing data.\n *\n *  @example\n *  ```typescript\n *  const signer = EllipticSigner(process.env.PRIVATE_KEY)\n *  signer(data).then( (signature: string) => {\n *    ...\n *  })\n *  ```\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                        a configured signer function\n */\nfunction EllipticSigner(hexPrivateKey: string): Signer {\n  return ES256KSigner(hexPrivateKey)\n}\n\nexport default EllipticSigner\n","import { sign } from '@stablelib/ed25519'\nimport { Signer } from '../JWT'\nimport { bytesToBase64url, parseKey, stringToBytes } from '../util'\n\n/**\n *  Creates a configured signer function for signing data using the EdDSA (Ed25519) algorithm.\n *\n *  The signing function itself takes the data as a `Uint8Array` or `string` and returns a `base64Url`-encoded signature\n *\n *  @example\n *  ```typescript\n *  const sign: Signer = EdDSASigner(process.env.PRIVATE_KEY)\n *  const signature: string = await sign(data)\n *  ```\n *\n *  @param    {String}    secretKey   a 64 byte secret key as `Uint8Array` or encoded as `base64`, `base58`, or `hex` string\n *  @return   {Function}              a configured signer function `(data: string | Uint8Array): Promise<string>`\n */\nexport function EdDSASigner(secretKey: string | Uint8Array): Signer {\n  const privateKeyBytes: Uint8Array = parseKey(secretKey)\n  if (privateKeyBytes.length !== 64) {\n    throw new Error(`bad_key: Invalid private key format. Expecting 64 bytes, but got ${privateKeyBytes.length}`)\n  }\n  return async (data: string | Uint8Array): Promise<string> => {\n    const dataBytes: Uint8Array = typeof data === 'string' ? stringToBytes(data) : data\n    const sig: Uint8Array = sign(privateKeyBytes, dataBytes)\n    return bytesToBase64url(sig)\n  }\n}\n","import { EdDSASigner as EdDSASigner } from './EdDSASigner'\nimport { Signer } from '../JWT'\n\n/**\n * @deprecated Please use EdDSASigner\n *\n *  The NaclSigner returns a configured function for signing data using the Ed25519 algorithm.\n *\n *  The signing function itself takes the data as a `string` or `Uint8Array` parameter and returns a `base64Url`-encoded signature.\n *\n *  @example\n *  const signer = NaclSigner(process.env.PRIVATE_KEY)\n *  const data: string = '...'\n *  signer(data).then( (signature: string) => {\n *    ...\n *  })\n *\n *  @param    {String}   base64PrivateKey    a 64 byte base64 encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction NaclSigner(base64PrivateKey: string): Signer {\n  return EdDSASigner(base64PrivateKey)\n}\n\nexport default NaclSigner\n","import { Signer, SignerAlgorithm } from './JWT'\nimport { EcdsaSignature, fromJose, toJose } from './util'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction instanceOfEcdsaSignature(object: any): object is EcdsaSignature {\n  return typeof object === 'object' && 'r' in object && 's' in object\n}\n\nexport function ES256KSignerAlg(recoverable?: boolean): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (instanceOfEcdsaSignature(signature)) {\n      return toJose(signature, recoverable)\n    } else {\n      if (recoverable && typeof fromJose(signature).recoveryParam === 'undefined') {\n        throw new Error(`not_supported: ES256K-R not supported when signer doesn't provide a recovery param`)\n      }\n      return signature\n    }\n  }\n}\n\nexport function Ed25519SignerAlg(): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (!instanceOfEcdsaSignature(signature)) {\n      return signature\n    } else {\n      throw new Error('invalid_config: expected a signer function that returns a string instead of signature object')\n    }\n  }\n}\n\ninterface SignerAlgorithms {\n  [alg: string]: SignerAlgorithm\n}\n\nconst algorithms: SignerAlgorithms = {\n  ES256K: ES256KSignerAlg(),\n  // This is a non-standard algorithm but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/146\n  'ES256K-R': ES256KSignerAlg(true),\n  // This is actually incorrect but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/130\n  Ed25519: Ed25519SignerAlg(),\n  EdDSA: Ed25519SignerAlg(),\n}\n\nfunction SignerAlg(alg: string): SignerAlgorithm {\n  const impl: SignerAlgorithm = algorithms[alg]\n  if (!impl) throw new Error(`not_supported: Unsupported algorithm ${alg}`)\n  return impl\n}\n\nexport default SignerAlg\n","import { ec as EC, SignatureInput } from 'elliptic'\nimport { sha256, toEthereumAddress } from './Digest'\nimport { verify } from '@stablelib/ed25519'\nimport type { VerificationMethod } from 'did-resolver'\nimport { hexToBytes, base58ToBytes, base64ToBytes, bytesToHex, EcdsaSignature, stringToBytes } from './util'\n\nconst secp256k1 = new EC('secp256k1')\n\n// converts a JOSE signature to it's components\nexport function toSignatureObject(signature: string, recoverable = false): EcdsaSignature {\n  const rawSig: Uint8Array = base64ToBytes(signature)\n  if (rawSig.length !== (recoverable ? 65 : 64)) {\n    throw new Error('wrong signature length')\n  }\n  const r: string = bytesToHex(rawSig.slice(0, 32))\n  const s: string = bytesToHex(rawSig.slice(32, 64))\n  const sigObj: EcdsaSignature = { r, s }\n  if (recoverable) {\n    sigObj.recoveryParam = rawSig[64]\n  }\n  return sigObj\n}\n\ninterface LegacyVerificationMethod extends VerificationMethod {\n  publicKeyBase64: string\n}\n\nfunction extractPublicKeyBytes(pk: VerificationMethod): Uint8Array {\n  if (pk.publicKeyBase58) {\n    return base58ToBytes(pk.publicKeyBase58)\n  } else if ((<LegacyVerificationMethod>pk).publicKeyBase64) {\n    return base64ToBytes((<LegacyVerificationMethod>pk).publicKeyBase64)\n  } else if (pk.publicKeyHex) {\n    return hexToBytes(pk.publicKeyHex)\n  } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === 'secp256k1' && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {\n    return hexToBytes(\n      secp256k1\n        .keyFromPublic({\n          x: bytesToHex(base64ToBytes(pk.publicKeyJwk.x)),\n          y: bytesToHex(base64ToBytes(pk.publicKeyJwk.y)),\n        })\n        .getPublic('hex')\n    )\n  }\n  return new Uint8Array()\n}\n\nexport function verifyES256K(\n  data: string,\n  signature: string,\n  authenticators: VerificationMethod[]\n): VerificationMethod {\n  const hash: Uint8Array = sha256(data)\n  const sigObj: EcdsaSignature = toSignatureObject(signature)\n  const fullPublicKeys = authenticators.filter(({ ethereumAddress, blockchainAccountId }) => {\n    return typeof ethereumAddress === 'undefined' && typeof blockchainAccountId === 'undefined'\n  })\n  const ethAddressKeys = authenticators.filter(({ ethereumAddress, blockchainAccountId }) => {\n    return typeof ethereumAddress !== 'undefined' || typeof blockchainAccountId !== undefined\n  })\n\n  let signer: VerificationMethod | undefined = fullPublicKeys.find((pk: VerificationMethod) => {\n    try {\n      const pubBytes = extractPublicKeyBytes(pk)\n      return secp256k1.keyFromPublic(pubBytes).verify(hash, <SignatureInput>sigObj)\n    } catch (err) {\n      return false\n    }\n  })\n\n  if (!signer && ethAddressKeys.length > 0) {\n    signer = verifyRecoverableES256K(data, signature, ethAddressKeys)\n  }\n\n  if (!signer) throw new Error('invalid_signature: Signature invalid for JWT')\n  return signer\n}\n\nexport function verifyRecoverableES256K(\n  data: string,\n  signature: string,\n  authenticators: VerificationMethod[]\n): VerificationMethod {\n  let signatures: EcdsaSignature[]\n  if (signature.length > 86) {\n    signatures = [toSignatureObject(signature, true)]\n  } else {\n    const so = toSignatureObject(signature, false)\n    signatures = [\n      { ...so, recoveryParam: 0 },\n      { ...so, recoveryParam: 1 },\n    ]\n  }\n\n  const checkSignatureAgainstSigner = (sigObj: EcdsaSignature): VerificationMethod | undefined => {\n    const hash: Uint8Array = sha256(data)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const recoveredKey: any = secp256k1.recoverPubKey(hash, <SignatureInput>sigObj, <number>sigObj.recoveryParam)\n    const recoveredPublicKeyHex: string = recoveredKey.encode('hex')\n    const recoveredCompressedPublicKeyHex: string = recoveredKey.encode('hex', true)\n    const recoveredAddress: string = toEthereumAddress(recoveredPublicKeyHex)\n\n    const signer: VerificationMethod | undefined = authenticators.find((pk: VerificationMethod) => {\n      const keyHex = bytesToHex(extractPublicKeyBytes(pk))\n      return (\n        keyHex === recoveredPublicKeyHex ||\n        keyHex === recoveredCompressedPublicKeyHex ||\n        pk.ethereumAddress?.toLowerCase() === recoveredAddress ||\n        pk.blockchainAccountId?.split('@eip155')?.[0].toLowerCase() === recoveredAddress\n      )\n    })\n\n    return signer\n  }\n\n  const signer: VerificationMethod[] = signatures\n    .map(checkSignatureAgainstSigner)\n    .filter((key) => typeof key !== 'undefined') as VerificationMethod[]\n\n  if (signer.length === 0) throw new Error('invalid_signature: Signature invalid for JWT')\n  return signer[0]\n}\n\nexport function verifyEd25519(\n  data: string,\n  signature: string,\n  authenticators: VerificationMethod[]\n): VerificationMethod {\n  const clear: Uint8Array = stringToBytes(data)\n  const sig: Uint8Array = base64ToBytes(signature)\n  const signer = authenticators.find((pk: VerificationMethod) => {\n    return verify(extractPublicKeyBytes(pk), clear, sig)\n  })\n  if (!signer) throw new Error('invalid_signature: Signature invalid for JWT')\n  return signer\n}\n\ntype Verifier = (data: string, signature: string, authenticators: VerificationMethod[]) => VerificationMethod\ninterface Algorithms {\n  [name: string]: Verifier\n}\nconst algorithms: Algorithms = {\n  ES256K: verifyES256K,\n  // This is a non-standard algorithm but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/146\n  'ES256K-R': verifyRecoverableES256K,\n  // This is actually incorrect but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/130\n  Ed25519: verifyEd25519,\n  EdDSA: verifyEd25519,\n}\n\nfunction VerifierAlgorithm(alg: string): Verifier {\n  const impl: Verifier = algorithms[alg]\n  if (!impl) throw new Error(`not_supported: Unsupported algorithm ${alg}`)\n  return impl\n}\n\nVerifierAlgorithm.toSignatureObject = toSignatureObject\n\nexport default VerifierAlgorithm\n","import canonicalizeData from 'canonicalize'\nimport type { DIDDocument, DIDResolutionResult, Resolvable, VerificationMethod } from 'did-resolver'\nimport SignerAlg from './SignerAlgorithm'\nimport { decodeBase64url, EcdsaSignature, encodeBase64url } from './util'\nimport VerifierAlgorithm from './VerifierAlgorithm'\n\nexport type Signer = (data: string | Uint8Array) => Promise<EcdsaSignature | string>\nexport type SignerAlgorithm = (payload: string, signer: Signer) => Promise<string>\n\nexport type ProofPurposeTypes =\n  | 'assertionMethod'\n  | 'authentication'\n  // | 'keyAgreement' // keyAgreement VerificationMethod should not be used for signing\n  | 'capabilityDelegation'\n  | 'capabilityInvocation'\n\nexport interface JWTOptions {\n  issuer: string\n  signer: Signer\n  /**\n   * @deprecated Please use `header.alg` to specify the JWT algorithm.\n   */\n  alg?: string\n  expiresIn?: number\n  canonicalize?: boolean\n}\n\nexport interface JWTVerifyOptions {\n  /** @deprecated Please use `proofPurpose: 'authentication' instead` */\n  auth?: boolean\n  audience?: string\n  callbackUrl?: string\n  resolver?: Resolvable\n  skewTime?: number\n  /** See https://www.w3.org/TR/did-spec-registries/#verification-relationships */\n  proofPurpose?: ProofPurposeTypes\n}\n\nexport interface JWSCreationOptions {\n  canonicalize?: boolean\n}\n\nexport interface DIDAuthenticator {\n  authenticators: VerificationMethod[]\n  issuer: string\n  didResolutionResult: DIDResolutionResult\n}\n\nexport interface JWTHeader {\n  typ: 'JWT'\n  alg: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\nexport interface JWTPayload {\n  iss?: string\n  sub?: string\n  aud?: string | string[]\n  iat?: number\n  nbf?: number\n  exp?: number\n  rexp?: number\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\nexport interface JWTDecoded {\n  header: JWTHeader\n  payload: JWTPayload\n  signature: string\n  data: string\n}\n\nexport interface JWSDecoded {\n  header: JWTHeader\n  payload: string\n  signature: string\n  data: string\n}\n\nexport interface JWTVerified {\n  payload: Partial<JWTPayload>\n  didResolutionResult: DIDResolutionResult\n  issuer: string\n  signer: VerificationMethod\n  jwt: string\n}\n\nexport interface PublicKeyTypes {\n  [name: string]: string[]\n}\nexport const SUPPORTED_PUBLIC_KEY_TYPES: PublicKeyTypes = {\n  ES256K: [\n    'EcdsaSecp256k1VerificationKey2019',\n    /**\n     * Equivalent to EcdsaSecp256k1VerificationKey2019 when key is an ethereumAddress\n     */\n    'EcdsaSecp256k1RecoveryMethod2020',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'Secp256k1VerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'Secp256k1SignatureVerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'EcdsaPublicKeySecp256k1',\n  ],\n  'ES256K-R': [\n    'EcdsaSecp256k1VerificationKey2019',\n    /**\n     * Equivalent to EcdsaSecp256k1VerificationKey2019 when key is an ethereumAddress\n     */\n    'EcdsaSecp256k1RecoveryMethod2020',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'Secp256k1VerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'Secp256k1SignatureVerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'EcdsaPublicKeySecp256k1',\n  ],\n  Ed25519: ['ED25519SignatureVerification', 'Ed25519VerificationKey2018'],\n  EdDSA: ['ED25519SignatureVerification', 'Ed25519VerificationKey2018'],\n}\n\ntype LegacyVerificationMethod = { publicKey?: string }\n\nconst defaultAlg = 'ES256K'\nconst DID_JSON = 'application/did+json'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction encodeSection(data: any, shouldCanonicalize = false): string {\n  if (shouldCanonicalize) {\n    return encodeBase64url(<string>canonicalizeData(data))\n  } else {\n    return encodeBase64url(JSON.stringify(data))\n  }\n}\n\nexport const NBF_SKEW = 300\n\nfunction decodeJWS(jws: string): JWSDecoded {\n  const parts = jws.match(/^([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)$/)\n  if (parts) {\n    return {\n      header: JSON.parse(decodeBase64url(parts[1])),\n      payload: parts[2],\n      signature: parts[3],\n      data: `${parts[1]}.${parts[2]}`,\n    }\n  }\n  throw new Error('invalid_argument: Incorrect format JWS')\n}\n\n/**  @module did-jwt/JWT */\n\n/**\n *  Decodes a JWT and returns an object representing the payload\n *\n *  @example\n *  decodeJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpYXQiOjE1...')\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @return   {Object}                               a JS object representing the decoded JWT\n */\nexport function decodeJWT(jwt: string): JWTDecoded {\n  if (!jwt) throw new Error('invalid_argument: no JWT passed into decodeJWT')\n  try {\n    const jws = decodeJWS(jwt)\n    const decodedJwt: JWTDecoded = Object.assign(jws, { payload: JSON.parse(decodeBase64url(jws.payload)) })\n    return decodedJwt\n  } catch (e) {\n    throw new Error('invalid_argument: Incorrect format JWT')\n  }\n}\n\n/**\n *  Creates a signed JWS given a payload, a signer, and an optional header.\n *\n *  @example\n *  const signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  const jws = await createJWS({ my: 'payload' }, signer)\n *\n *  @param    {Object}            payload           payload object\n *  @param    {Signer}            signer            a signer, see `ES256KSigner or `EdDSASigner`\n *  @param    {Object}            header            optional object to specify or customize the JWS header\n *  @return   {Promise<Object, Error>}              a promise which resolves with a JWS string or rejects with an error\n */\nexport async function createJWS(\n  payload: string | Partial<JWTPayload>,\n  signer: Signer,\n  header: Partial<JWTHeader> = {},\n  options: JWSCreationOptions = {}\n): Promise<string> {\n  if (!header.alg) header.alg = defaultAlg\n  const encodedPayload = typeof payload === 'string' ? payload : encodeSection(payload, options.canonicalize)\n  const signingInput: string = [encodeSection(header, options.canonicalize), encodedPayload].join('.')\n\n  const jwtSigner: SignerAlgorithm = SignerAlg(header.alg)\n  const signature: string = await jwtSigner(signingInput, signer)\n  return [signingInput, signature].join('.')\n}\n\n/**\n *  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is over.\n *\n *  @example\n *  const signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {\n *      ...\n *  })\n *\n *  @param    {Object}            payload               payload object\n *  @param    {Object}            [options]             an unsigned credential object\n *  @param    {String}            options.issuer        The DID of the issuer (signer) of JWT\n *  @param    {String}            options.alg           [DEPRECATED] The JWT signing algorithm to use. Supports: [ES256K, ES256K-R, Ed25519, EdDSA], Defaults to: ES256K.\n *                                                      Please use `header.alg` to specify the algorithm\n *  @param    {Signer}            options.signer        a `Signer` function, Please see `ES256KSigner` or `EdDSASigner`\n *  @param    {boolean}           options.canonicalize  optional flag to canonicalize header and payload before signing\n *  @param    {Object}            header                optional object to specify or customize the JWT header\n *  @return   {Promise<Object, Error>}                  a promise which resolves with a signed JSON Web Token or rejects with an error\n */\nexport async function createJWT(\n  payload: Partial<JWTPayload>,\n  { issuer, signer, alg, expiresIn, canonicalize }: JWTOptions,\n  header: Partial<JWTHeader> = {}\n): Promise<string> {\n  if (!signer) throw new Error('missing_signer: No Signer functionality has been configured')\n  if (!issuer) throw new Error('missing_issuer: No issuing DID has been configured')\n  if (!header.typ) header.typ = 'JWT'\n  if (!header.alg) header.alg = alg\n  const timestamps: Partial<JWTPayload> = {\n    iat: Math.floor(Date.now() / 1000),\n    exp: undefined,\n  }\n  if (expiresIn) {\n    if (typeof expiresIn === 'number') {\n      timestamps.exp = <number>(payload.nbf || timestamps.iat) + Math.floor(expiresIn)\n    } else {\n      throw new Error('invalid_argument: JWT expiresIn is not a number')\n    }\n  }\n  const fullPayload = { ...timestamps, ...payload, iss: issuer }\n  return createJWS(fullPayload, signer, header, { canonicalize })\n}\n\nfunction verifyJWSDecoded(\n  { header, data, signature }: JWSDecoded,\n  pubKeys: VerificationMethod | VerificationMethod[]\n): VerificationMethod {\n  if (!Array.isArray(pubKeys)) pubKeys = [pubKeys]\n  const signer: VerificationMethod = VerifierAlgorithm(header.alg)(data, signature, pubKeys)\n  return signer\n}\n\n/**\n *  Verifies given JWS. If the JWS is valid, returns the public key that was\n *  used to sign the JWS, or throws an `Error` if none of the `pubKeys` match.\n *\n *  @example\n *  const pubKey = verifyJWS('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', { publicKeyHex: '0x12341...' })\n *\n *  @param    {String}                          jws         A JWS string to verify\n *  @param    {Array<VerificationMethod> | VerificationMethod}    pubKeys     The public keys used to verify the JWS\n *  @return   {VerificationMethod}                       The public key used to sign the JWS\n */\nexport function verifyJWS(jws: string, pubKeys: VerificationMethod | VerificationMethod[]): VerificationMethod {\n  const jwsDecoded: JWSDecoded = decodeJWS(jws)\n  return verifyJWSDecoded(jwsDecoded, pubKeys)\n}\n\n/**\n *  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,\n *  and the did doc of the issuer of the JWT.\n *\n *  @example\n *  verifyJWT('did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...'}).then(obj => {\n *      const did = obj.did // DID of signer\n *      const payload = obj.payload\n *      const doc = obj.doc // DID Document of signer\n *      const jwt = obj.jwt\n *      const signerKeyId = obj.signerKeyId // ID of key in DID document that signed JWT\n *      ...\n *  })\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @param    {Object}            [options]           an unsigned credential object\n *  @param    {Boolean}           options.auth        Require signer to be listed in the authentication section of the DID document (for Authentication purposes)\n *  @param    {String}            options.audience    DID of the recipient of the JWT\n *  @param    {String}            options.callbackUrl callback url in JWT\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an error\n */\nexport async function verifyJWT(\n  jwt: string,\n  options: JWTVerifyOptions = {\n    resolver: undefined,\n    auth: undefined,\n    audience: undefined,\n    callbackUrl: undefined,\n    skewTime: undefined,\n    proofPurpose: undefined,\n  }\n): Promise<JWTVerified> {\n  if (!options.resolver) throw new Error('missing_resolver: No DID resolver has been configured')\n  const { payload, header, signature, data }: JWTDecoded = decodeJWT(jwt)\n  const proofPurpose: ProofPurposeTypes | undefined = Object.prototype.hasOwnProperty.call(options, 'auth')\n    ? options.auth\n      ? 'authentication'\n      : undefined\n    : options.proofPurpose\n  const { didResolutionResult, authenticators, issuer }: DIDAuthenticator = await resolveAuthenticator(\n    options.resolver,\n    header.alg,\n    payload.iss || '',\n    proofPurpose\n  )\n  const signer: VerificationMethod = await verifyJWSDecoded({ header, data, signature } as JWSDecoded, authenticators)\n  const now: number = Math.floor(Date.now() / 1000)\n  const skewTime = typeof options.skewTime !== 'undefined' && options.skewTime >= 0 ? options.skewTime : NBF_SKEW\n  if (signer) {\n    const nowSkewed = now + skewTime\n    if (payload.nbf) {\n      if (payload.nbf > nowSkewed) {\n        throw new Error(`invalid_jwt: JWT not valid before nbf: ${payload.nbf}`)\n      }\n    } else if (payload.iat && payload.iat > nowSkewed) {\n      throw new Error(`invalid_jwt: JWT not valid yet (issued in the future) iat: ${payload.iat}`)\n    }\n    if (payload.exp && payload.exp <= now - skewTime) {\n      throw new Error(`invalid_jwt: JWT has expired: exp: ${payload.exp} < now: ${now}`)\n    }\n    if (payload.aud) {\n      if (!options.audience && !options.callbackUrl) {\n        throw new Error('invalid_config: JWT audience is required but your app address has not been configured')\n      }\n      const audArray = Array.isArray(payload.aud) ? payload.aud : [payload.aud]\n      const matchedAudience = audArray.find((item) => options.audience === item || options.callbackUrl === item)\n\n      if (typeof matchedAudience === 'undefined') {\n        throw new Error(`invalid_config: JWT audience does not match your DID or callback url`)\n      }\n    }\n    return { payload, didResolutionResult, issuer, signer, jwt }\n  }\n  throw new Error(\n    `invalid_signature: JWT not valid. issuer DID document does not contain a verificationMethod that matches the signature.`\n  )\n}\n\n/**\n * Resolves relevant public keys or other authenticating material used to verify signature from the DID document of provided DID\n *\n *  @example\n *  resolveAuthenticator(resolver, 'ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {\n *      const payload = obj.payload\n *      const profile = obj.profile\n *      const jwt = obj.jwt\n *      ...\n *  })\n *\n *  @param    {String}            alg                a JWT algorithm\n *  @param    {String}            did                a Decentralized IDentifier (DID) to lookup\n *  @param    {Boolean}           auth               Restrict public keys to ones specifically listed in the 'authentication' section of DID document\n *  @return   {Promise<DIDAuthenticator>}               a promise which resolves with a response object containing an array of authenticators or if non exist rejects with an error\n */\nexport async function resolveAuthenticator(\n  resolver: Resolvable,\n  alg: string,\n  issuer: string,\n  proofPurpose?: ProofPurposeTypes\n): Promise<DIDAuthenticator> {\n  const types: string[] = SUPPORTED_PUBLIC_KEY_TYPES[alg]\n  if (!types || types.length === 0) {\n    throw new Error(`not_supported: No supported signature types for algorithm ${alg}`)\n  }\n  let didResult: DIDResolutionResult\n\n  const result = (await resolver.resolve(issuer, { accept: DID_JSON })) as unknown\n  // support legacy resolvers that do not produce DIDResolutionResult\n  if (Object.getOwnPropertyNames(result).indexOf('didDocument') === -1) {\n    didResult = {\n      didDocument: result as DIDDocument,\n      didDocumentMetadata: {},\n      didResolutionMetadata: { contentType: DID_JSON },\n    }\n  } else {\n    didResult = result as DIDResolutionResult\n  }\n\n  if (didResult.didResolutionMetadata?.error || didResult.didDocument == null) {\n    const { error, message } = didResult.didResolutionMetadata\n    throw new Error(`resolver_error: Unable to resolve DID document for ${issuer}: ${error}, ${message || ''}`)\n  }\n\n  const getPublicKeyById = (verificationMethods: VerificationMethod[], pubid?: string): VerificationMethod | null => {\n    const filtered = verificationMethods.filter(({ id }) => pubid === id)\n    return filtered.length > 0 ? filtered[0] : null\n  }\n\n  let publicKeysToCheck: VerificationMethod[] = [\n    ...(didResult?.didDocument?.verificationMethod || []),\n    ...(didResult?.didDocument?.publicKey || []),\n  ]\n  if (typeof proofPurpose === 'string') {\n    // support legacy DID Documents that do not list assertionMethod\n    if (\n      proofPurpose.startsWith('assertion') &&\n      !Object.getOwnPropertyNames(didResult?.didDocument).includes('assertionMethod')\n    ) {\n      didResult.didDocument = { ...(<DIDDocument>didResult.didDocument) }\n      didResult.didDocument.assertionMethod = [...publicKeysToCheck.map((pk) => pk.id)]\n    }\n\n    publicKeysToCheck = (didResult.didDocument[proofPurpose] || [])\n      .map((verificationMethod) => {\n        if (typeof verificationMethod === 'string') {\n          return getPublicKeyById(publicKeysToCheck, verificationMethod)\n        } else if (typeof (<LegacyVerificationMethod>verificationMethod).publicKey === 'string') {\n          // this is a legacy format\n          return getPublicKeyById(publicKeysToCheck, (<LegacyVerificationMethod>verificationMethod).publicKey)\n        } else {\n          return <VerificationMethod>verificationMethod\n        }\n      })\n      .filter((key) => key != null) as VerificationMethod[]\n  }\n\n  const authenticators: VerificationMethod[] = publicKeysToCheck.filter(({ type }) =>\n    types.find((supported) => supported === type)\n  )\n\n  if (typeof proofPurpose === 'string' && (!authenticators || authenticators.length === 0)) {\n    throw new Error(\n      `no_suitable_keys: DID document for ${issuer} does not have public keys suitable for ${alg} with ${proofPurpose} purpose`\n    )\n  }\n  if (!authenticators || authenticators.length === 0) {\n    throw new Error(`no_suitable_keys: DID document for ${issuer} does not have public keys for ${alg}`)\n  }\n  return { authenticators, issuer, didResolutionResult: didResult }\n}\n","import { base64ToBytes, bytesToBase64url, decodeBase64url, toSealed } from './util'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ProtectedHeader = Record<string, any> & Partial<RecipientHeader>\n\n/**\n * The JWK representation of an ephemeral public key.\n * See https://www.rfc-editor.org/rfc/rfc7518.html#section-6\n */\ninterface EphemeralPublicKey {\n  kty?: string\n  //ECC\n  crv?: string\n  x?: string\n  y?: string\n  //RSA\n  n?: string\n  e?: string\n}\n\nexport interface RecipientHeader {\n  alg: string\n  iv: string\n  tag: string\n  epk?: EphemeralPublicKey\n  kid?: string\n  apv?: string\n  apu?: string\n}\n\nexport interface Recipient {\n  header: RecipientHeader\n  encrypted_key: string\n}\n\nexport interface JWE {\n  protected: string\n  iv: string\n  ciphertext: string\n  tag: string\n  aad?: string\n  recipients?: Recipient[]\n}\n\nexport interface EncryptionResult {\n  ciphertext: Uint8Array\n  tag: Uint8Array\n  iv: Uint8Array\n  protectedHeader?: string\n  recipient?: Recipient\n  cek?: Uint8Array\n}\n\nexport interface Encrypter {\n  alg: string\n  enc: string\n  encrypt: (cleartext: Uint8Array, protectedHeader: ProtectedHeader, aad?: Uint8Array) => Promise<EncryptionResult>\n  encryptCek?: (cek: Uint8Array) => Promise<Recipient>\n}\n\nexport interface Decrypter {\n  alg: string\n  enc: string\n  decrypt: (sealed: Uint8Array, iv: Uint8Array, aad?: Uint8Array, recipient?: Recipient) => Promise<Uint8Array | null>\n}\n\nfunction validateJWE(jwe: JWE) {\n  if (!(jwe.protected && jwe.iv && jwe.ciphertext && jwe.tag)) {\n    throw new Error('bad_jwe: missing properties')\n  }\n  if (jwe.recipients) {\n    jwe.recipients.map((rec) => {\n      if (!(rec.header && rec.encrypted_key)) {\n        throw new Error('bad_jwe: malformed recipients')\n      }\n    })\n  }\n}\n\nfunction encodeJWE({ ciphertext, tag, iv, protectedHeader, recipient }: EncryptionResult, aad?: Uint8Array): JWE {\n  const jwe: JWE = {\n    protected: <string>protectedHeader,\n    iv: bytesToBase64url(iv),\n    ciphertext: bytesToBase64url(ciphertext),\n    tag: bytesToBase64url(tag),\n  }\n  if (aad) jwe.aad = bytesToBase64url(aad)\n  if (recipient) jwe.recipients = [recipient]\n  return jwe\n}\n\nexport async function createJWE(\n  cleartext: Uint8Array,\n  encrypters: Encrypter[],\n  protectedHeader = {},\n  aad?: Uint8Array\n): Promise<JWE> {\n  if (encrypters[0].alg === 'dir') {\n    if (encrypters.length > 1) throw new Error('not_supported: Can only do \"dir\" encryption to one key.')\n    const encryptionResult = await encrypters[0].encrypt(cleartext, protectedHeader, aad)\n    return encodeJWE(encryptionResult, aad)\n  } else {\n    const tmpEnc = encrypters[0].enc\n    if (!encrypters.reduce((acc, encrypter) => acc && encrypter.enc === tmpEnc, true)) {\n      throw new Error('invalid_argument: Incompatible encrypters passed')\n    }\n    let cek\n    let jwe\n    for (const encrypter of encrypters) {\n      if (!cek) {\n        const encryptionResult = await encrypter.encrypt(cleartext, protectedHeader, aad)\n        cek = encryptionResult.cek\n        jwe = encodeJWE(encryptionResult, aad)\n      } else {\n        const recipient = await encrypter.encryptCek?.(cek)\n        if (recipient) {\n          jwe?.recipients?.push(recipient)\n        }\n      }\n    }\n    return <JWE>jwe\n  }\n}\n\nexport async function decryptJWE(jwe: JWE, decrypter: Decrypter): Promise<Uint8Array> {\n  validateJWE(jwe)\n  const protHeader = JSON.parse(decodeBase64url(jwe.protected))\n  if (protHeader.enc !== decrypter.enc)\n    throw new Error(`not_supported: Decrypter does not supported: '${protHeader.enc}'`)\n  const sealed = toSealed(jwe.ciphertext, jwe.tag)\n  const aad = new Uint8Array(Buffer.from(jwe.aad ? `${jwe.protected}.${jwe.aad}` : jwe.protected))\n  let cleartext = null\n  if (protHeader.alg === 'dir' && decrypter.alg === 'dir') {\n    cleartext = await decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad)\n  } else if (!jwe.recipients || jwe.recipients.length === 0) {\n    throw new Error('bad_jwe: missing recipients')\n  } else {\n    for (let i = 0; !cleartext && i < jwe.recipients.length; i++) {\n      const recipient = jwe.recipients[i]\n      Object.assign(recipient.header, protHeader)\n      if (recipient.header.alg === decrypter.alg) {\n        cleartext = await decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad, recipient)\n      }\n    }\n  }\n  if (cleartext === null) throw new Error('failure: Failed to decrypt')\n  return cleartext\n}\n","import { sharedKey } from '@stablelib/x25519'\n\n/**\n * A wrapper around `mySecretKey` that can compute a shared secret using `theirPublicKey`.\n * The promise should resolve to a `Uint8Array` containing the raw shared secret.\n *\n * This method is meant to be used when direct access to a secret key is impossible or not desired.\n *\n * @param theirPublicKey `Uint8Array` the other party's public key\n * @returns a `Promise` that resolves to a `Uint8Array` representing the computed shared secret\n */\nexport type ECDH = (theirPublicKey: Uint8Array) => Promise<Uint8Array>\n\n/**\n * Wraps an X25519 secret key into an ECDH method that can be used to compute a shared secret with a public key.\n * @param mySecretKey A `Uint8Array` of length 32 representing the bytes of my secret key\n * @returns an `ECDH` method with the signature `(theirPublicKey: Uint8Array) => Promise<Uint8Array>`\n *\n * @throws 'invalid_argument:...' if the secret key size is wrong\n */\nexport function createX25519ECDH(mySecretKey: Uint8Array): ECDH {\n  if (mySecretKey.length !== 32) {\n    throw new Error('invalid_argument: incorrect secret key length for X25519')\n  }\n  return async (theirPublicKey: Uint8Array): Promise<Uint8Array> => {\n    if (theirPublicKey.length !== 32) {\n      throw new Error('invalid_argument: incorrect publicKey key length for X25519')\n    }\n    return sharedKey(mySecretKey, theirPublicKey)\n  }\n}\n","import { XChaCha20Poly1305 } from '@stablelib/xchacha20poly1305'\nimport { generateKeyPair, sharedKey } from '@stablelib/x25519'\nimport { randomBytes } from '@stablelib/random'\nimport { concatKDF } from './Digest'\nimport { bytesToBase64url, base58ToBytes, encodeBase64url, toSealed, base64ToBytes } from './util'\nimport { Recipient, EncryptionResult, Encrypter, Decrypter, RecipientHeader, ProtectedHeader } from './JWE'\nimport type { VerificationMethod, Resolvable } from 'did-resolver'\nimport { ECDH } from './ECDH'\n\n/**\n * Extra parameters for JWE using authenticated encryption\n */\nexport type AuthEncryptParams = {\n  /**\n   * recipient key ID\n   */\n  kid?: string\n\n  /**\n   * See {@link https://datatracker.ietf.org/doc/html/rfc7518#section-4.6.1.2}\n   * base64url encoded\n   */\n  apu?: string\n\n  /**\n   * See {@link https://datatracker.ietf.org/doc/html/rfc7518#section-4.6.1.3}\n   * base64url encoded\n   */\n  apv?: string\n}\n\n/**\n * Extra parameters for JWE using anonymous encryption\n */\nexport type AnonEncryptParams = {\n  /**\n   * recipient key ID\n   */\n  kid?: string\n}\n\n/**\n * Recommended encrypter for authenticated encryption (i.e. sender authentication and requires\n * sender private key to encrypt the data).\n * Uses {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU v3 } and\n * {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW v2 }.\n *\n * @param recipientPublicKey the byte array representing the recipient public key\n * @param senderSecret either a Uint8Array representing the sender secret key or\n *   an ECDH function that wraps the key and can promise a shared secret given a public key\n * @param options {@link AuthEncryptParams} used to specify extra header parameters\n *\n * @returns an {@link Encrypter} instance usable with {@link createJWE}\n *\n * NOTE: ECDH-1PU and XC20PKW are proposed drafts in IETF and not a standard yet and\n * are subject to change as new revisions or until the official CFRG specification are released.\n *\n * @beta\n */\nexport function createAuthEncrypter(\n  recipientPublicKey: Uint8Array,\n  senderSecret: Uint8Array | ECDH,\n  options: Partial<AuthEncryptParams> = {}\n): Encrypter {\n  return xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2(recipientPublicKey, senderSecret, options)\n}\n\n/**\n * Recommended encrypter for anonymous encryption (i.e. no sender authentication).\n * Uses {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | ECDH-ES+XC20PKW v2}.\n *\n * @param publicKey the byte array representing the recipient public key\n * @param options {@link AnonEncryptParams} used to specify the recipient key ID (`kid`)\n *\n * @returns an {@link Encrypter} instance usable with {@link createJWE}\n *\n * NOTE: ECDH-ES+XC20PKW is a proposed draft in IETF and not a standard yet and\n * is subject to change as new revisions or until the official CFRG specification is released.\n *\n * @beta\n */\nexport function createAnonEncrypter(publicKey: Uint8Array, options: Partial<AnonEncryptParams> = {}): Encrypter {\n  return x25519Encrypter(publicKey, options?.kid)\n}\n\n/**\n * Recommended decrypter for authenticated encryption (i.e. sender authentication and requires\n * sender public key to decrypt the data).\n * Uses {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU v3 } and\n * {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW v2 }.\n *\n * @param recipientSecret either a Uint8Array representing the recipient secret key or\n *   an ECDH function that wraps the key and can promise a shared secret given a public key\n * @param senderPublicKey the byte array representing the sender public key\n *\n * @returns a {@link Decrypter} instance usable with {@link decryptJWE}\n *\n * NOTE: ECDH-1PU and XC20PKW are proposed drafts in IETF and not a standard yet and\n * are subject to change as new revisions or until the official CFRG specification are released.\n *\n * @beta\n */\nexport function createAuthDecrypter(recipientSecret: Uint8Array | ECDH, senderPublicKey: Uint8Array): Decrypter {\n  return xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2(recipientSecret, senderPublicKey)\n}\n\n/**\n * Recommended decrypter for anonymous encryption (i.e. no sender authentication).\n * Uses {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | ECDH-ES+XC20PKW v2 }.\n *\n * @param recipientSecret either a Uint8Array representing the recipient secret key or\n *   an ECDH function that wraps the key and can promise a shared secret given a public key\n *\n * @returns a {@link Decrypter} instance usable with {@link decryptJWE}\n *\n * NOTE: ECDH-ES+XC20PKW is a proposed draft in IETF and not a standard yet and\n * is subject to change as new revisions or until the official CFRG specification is released.\n *\n * @beta\n */\nexport function createAnonDecrypter(recipientSecret: Uint8Array | ECDH): Decrypter {\n  return x25519Decrypter(recipientSecret)\n}\n\nfunction xc20pEncrypter(key: Uint8Array): (cleartext: Uint8Array, aad?: Uint8Array) => EncryptionResult {\n  const cipher = new XChaCha20Poly1305(key)\n  return (cleartext: Uint8Array, aad?: Uint8Array) => {\n    const iv = randomBytes(cipher.nonceLength)\n    const sealed = cipher.seal(iv, cleartext, aad)\n    return {\n      ciphertext: sealed.subarray(0, sealed.length - cipher.tagLength),\n      tag: sealed.subarray(sealed.length - cipher.tagLength),\n      iv,\n    }\n  }\n}\n\nexport function xc20pDirEncrypter(key: Uint8Array): Encrypter {\n  const xc20pEncrypt = xc20pEncrypter(key)\n  const enc = 'XC20P'\n  const alg = 'dir'\n  async function encrypt(\n    cleartext: Uint8Array,\n    protectedHeader: ProtectedHeader = {},\n    aad?: Uint8Array\n  ): Promise<EncryptionResult> {\n    const protHeader = encodeBase64url(JSON.stringify(Object.assign({ alg }, protectedHeader, { enc })))\n    const encodedAad = new Uint8Array(Buffer.from(aad ? `${protHeader}.${bytesToBase64url(aad)}` : protHeader))\n    return {\n      ...xc20pEncrypt(cleartext, encodedAad),\n      protectedHeader: protHeader,\n    }\n  }\n  return { alg, enc, encrypt }\n}\n\nexport function xc20pDirDecrypter(key: Uint8Array): Decrypter {\n  const cipher = new XChaCha20Poly1305(key)\n  async function decrypt(sealed: Uint8Array, iv: Uint8Array, aad?: Uint8Array): Promise<Uint8Array | null> {\n    return cipher.open(iv, sealed, aad)\n  }\n  return { alg: 'dir', enc: 'XC20P', decrypt }\n}\n\nexport function x25519Encrypter(publicKey: Uint8Array, kid?: string): Encrypter {\n  const alg = 'ECDH-ES+XC20PKW'\n  const keyLen = 256\n  const crv = 'X25519'\n  async function encryptCek(cek: Uint8Array): Promise<Recipient> {\n    const epk = generateKeyPair()\n    const sharedSecret = sharedKey(epk.secretKey, publicKey)\n    // Key Encryption Key\n    const kek = concatKDF(sharedSecret, keyLen, alg)\n    const res = xc20pEncrypter(kek)(cek)\n    const recipient: Recipient = {\n      encrypted_key: bytesToBase64url(res.ciphertext),\n      header: {\n        alg,\n        iv: bytesToBase64url(res.iv),\n        tag: bytesToBase64url(res.tag),\n        epk: { kty: 'OKP', crv, x: bytesToBase64url(epk.publicKey) },\n      },\n    }\n    if (kid) recipient.header.kid = kid\n    return recipient\n  }\n  async function encrypt(\n    cleartext: Uint8Array,\n    protectedHeader: ProtectedHeader = {},\n    aad?: Uint8Array\n  ): Promise<EncryptionResult> {\n    // we won't want alg to be set to dir from xc20pDirEncrypter\n    Object.assign(protectedHeader, { alg: undefined })\n    // Content Encryption Key\n    const cek = randomBytes(32)\n    return {\n      ...(await xc20pDirEncrypter(cek).encrypt(cleartext, protectedHeader, aad)),\n      recipient: await encryptCek(cek),\n      cek,\n    }\n  }\n  return { alg, enc: 'XC20P', encrypt, encryptCek }\n}\n\n/**\n * Implements ECDH-1PU+XC20PKW with XChaCha20Poly1305 based on the following specs:\n *   - {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW}\n *   - {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU}\n */\nexport function xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2(\n  recipientPublicKey: Uint8Array,\n  senderSecret: Uint8Array | ECDH,\n  options: Partial<AuthEncryptParams> = {}\n): Encrypter {\n  const alg = 'ECDH-1PU+XC20PKW'\n  const keyLen = 256\n  const crv = 'X25519'\n\n  let partyUInfo: Uint8Array\n  let partyVInfo: Uint8Array\n  if (options.apu !== undefined) partyUInfo = base64ToBytes(options.apu)\n  if (options.apv !== undefined) partyVInfo = base64ToBytes(options.apv)\n\n  async function encryptCek(cek: Uint8Array): Promise<Recipient> {\n    const epk = generateKeyPair()\n    const zE = sharedKey(epk.secretKey, recipientPublicKey)\n\n    // ECDH-1PU requires additional shared secret between\n    // static key of sender and static key of recipient\n    let zS\n    if (senderSecret instanceof Uint8Array) {\n      zS = sharedKey(senderSecret, recipientPublicKey)\n    } else {\n      zS = await senderSecret(recipientPublicKey)\n    }\n\n    const sharedSecret = new Uint8Array(zE.length + zS.length)\n    sharedSecret.set(zE)\n    sharedSecret.set(zS, zE.length)\n\n    // Key Encryption Key\n    const kek = concatKDF(sharedSecret, keyLen, alg, partyUInfo, partyVInfo)\n\n    const res = xc20pEncrypter(kek)(cek)\n    const recipient: Recipient = {\n      encrypted_key: bytesToBase64url(res.ciphertext),\n      header: {\n        alg,\n        iv: bytesToBase64url(res.iv),\n        tag: bytesToBase64url(res.tag),\n        epk: { kty: 'OKP', crv, x: bytesToBase64url(epk.publicKey) },\n      },\n    }\n    if (options.kid) recipient.header.kid = options.kid\n    if (options.apu) recipient.header.apu = options.apu\n    if (options.apv) recipient.header.apv = options.apv\n\n    return recipient\n  }\n  async function encrypt(\n    cleartext: Uint8Array,\n    protectedHeader: ProtectedHeader = {},\n    aad?: Uint8Array\n  ): Promise<EncryptionResult> {\n    // we won't want alg to be set to dir from xc20pDirEncrypter\n    Object.assign(protectedHeader, { alg: undefined })\n    // Content Encryption Key\n    const cek = randomBytes(32)\n    return {\n      ...(await xc20pDirEncrypter(cek).encrypt(cleartext, protectedHeader, aad)),\n      recipient: await encryptCek(cek),\n      cek,\n    }\n  }\n  return { alg, enc: 'XC20P', encrypt, encryptCek }\n}\n\nexport async function resolveX25519Encrypters(dids: string[], resolver: Resolvable): Promise<Encrypter[]> {\n  const encryptersForDID = async (did: string): Promise<Encrypter[]> => {\n    const { didResolutionMetadata, didDocument } = await resolver.resolve(did)\n    if (didResolutionMetadata?.error || didDocument == null) {\n      throw new Error(\n        `resolver_error: Could not resolve ${did}: ${didResolutionMetadata.error}, ${didResolutionMetadata.message}`\n      )\n    }\n    if (!didDocument.keyAgreement) throw new Error(`no_suitable_keys: Could not find x25519 key for ${did}`)\n    const agreementKeys: VerificationMethod[] = didDocument.keyAgreement\n      ?.map((key) => {\n        if (typeof key === 'string') {\n          return [...(didDocument.publicKey || []), ...(didDocument.verificationMethod || [])].find(\n            (pk) => pk.id === key\n          )\n        }\n        return key\n      })\n      .filter((key) => typeof key !== 'undefined') as VerificationMethod[]\n    const pks = agreementKeys.filter((key) => {\n      // TODO: should be able to use non base58 keys too\n      return key.type === 'X25519KeyAgreementKey2019' && Boolean(key.publicKeyBase58)\n    })\n    if (!pks.length) throw new Error(`no_suitable_keys: Could not find x25519 key for ${did}`)\n    return pks.map((pk) => x25519Encrypter(base58ToBytes(<string>pk.publicKeyBase58), pk.id))\n  }\n\n  const encrypterPromises = dids.map((did) => encryptersForDID(did))\n  const encrypterArrays = await Promise.all(encrypterPromises)\n  const flattenedArray = ([] as Encrypter[]).concat(...encrypterArrays)\n  return flattenedArray\n}\n\nfunction validateHeader(header?: ProtectedHeader) {\n  if (!(header && header.epk && header.iv && header.tag)) {\n    throw new Error('bad_jwe: malformed header')\n  }\n}\n\nexport function x25519Decrypter(receiverSecret: Uint8Array | ECDH): Decrypter {\n  const alg = 'ECDH-ES+XC20PKW'\n  const keyLen = 256\n  const crv = 'X25519'\n  async function decrypt(\n    sealed: Uint8Array,\n    iv: Uint8Array,\n    aad?: Uint8Array,\n    recipient?: Recipient\n  ): Promise<Uint8Array | null> {\n    validateHeader(recipient?.header)\n    recipient = <Recipient>recipient\n    if (recipient.header.epk?.crv !== crv || typeof recipient.header.epk.x == 'undefined') return null\n    const publicKey = base64ToBytes(recipient.header.epk.x)\n    let sharedSecret\n    if (receiverSecret instanceof Uint8Array) {\n      sharedSecret = sharedKey(receiverSecret, publicKey)\n    } else {\n      sharedSecret = await receiverSecret(publicKey)\n    }\n\n    // Key Encryption Key\n    const kek = concatKDF(sharedSecret, keyLen, alg)\n    // Content Encryption Key\n    const sealedCek = toSealed(<string>recipient.encrypted_key, recipient.header.tag)\n    const cek = await xc20pDirDecrypter(kek).decrypt(sealedCek, base64ToBytes(recipient.header.iv))\n    if (cek === null) return null\n\n    return xc20pDirDecrypter(cek).decrypt(sealed, iv, aad)\n  }\n  return { alg, enc: 'XC20P', decrypt }\n}\n\n/**\n * Implements ECDH-1PU+XC20PKW with XChaCha20Poly1305 based on the following specs:\n *   - {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW}\n *   - {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU}\n */\nexport function xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2(\n  recipientSecret: Uint8Array | ECDH,\n  senderPublicKey: Uint8Array\n): Decrypter {\n  const alg = 'ECDH-1PU+XC20PKW'\n  const keyLen = 256\n  const crv = 'X25519'\n  async function decrypt(\n    sealed: Uint8Array,\n    iv: Uint8Array,\n    aad?: Uint8Array,\n    recipient?: Recipient\n  ): Promise<Uint8Array | null> {\n    recipient = <Recipient>recipient\n    validateHeader(recipient.header)\n    if (recipient.header.epk?.crv !== crv || typeof recipient.header.epk.x == 'undefined') return null\n    // ECDH-1PU requires additional shared secret between\n    // static key of sender and static key of recipient\n    const publicKey = base64ToBytes(recipient.header.epk.x)\n    let zE: Uint8Array\n    let zS: Uint8Array\n\n    if (recipientSecret instanceof Uint8Array) {\n      zE = sharedKey(recipientSecret, publicKey)\n      zS = sharedKey(recipientSecret, senderPublicKey)\n    } else {\n      zE = await recipientSecret(publicKey)\n      zS = await recipientSecret(senderPublicKey)\n    }\n\n    const sharedSecret = new Uint8Array(zE.length + zS.length)\n    sharedSecret.set(zE)\n    sharedSecret.set(zS, zE.length)\n\n    // Key Encryption Key\n    let producerInfo\n    let consumerInfo\n    if (recipient.header.apu) producerInfo = base64ToBytes(recipient.header.apu)\n    if (recipient.header.apv) consumerInfo = base64ToBytes(recipient.header.apv)\n\n    const kek = concatKDF(sharedSecret, keyLen, alg, producerInfo, consumerInfo)\n    // Content Encryption Key\n    const sealedCek = toSealed(recipient.encrypted_key, recipient.header.tag)\n    const cek = await xc20pDirDecrypter(kek).decrypt(sealedCek, base64ToBytes(recipient.header.iv))\n    if (cek === null) return null\n\n    return xc20pDirDecrypter(cek).decrypt(sealed, iv, aad)\n  }\n  return { alg, enc: 'XC20P', decrypt }\n}\n"]},"metadata":{},"sourceType":"module"}